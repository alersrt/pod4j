/*
 * supports a RESTful API for the Libpod library
 * This documentation describes the Podman v2.x+ RESTful API. It consists of a Docker-compatible API and a Libpod API providing support for Podmanâ€™s unique features such as pods.  To start the service and keep it running for 5,000 seconds (-t 0 runs forever):  podman system service -t 5000 &  You can then use cURL on the socket using requests documented below.  NOTE: if you install the package podman-docker, it will create a symbolic link for /run/docker.sock to /run/podman/podman.sock  NOTE: Some fields in the API response JSON are encoded as omitempty, which means that if said field has a zero value, they will not be encoded in the API response. This is a feature to help reduce the size of the JSON responses returned via the API.  NOTE: Due to the limitations of [go-swagger](https://github.com/go-swagger/go-swagger), some field values that have a complex type show up as null in the docs as well as in the API responses. This is because the zero value for the field type is null. The field description in the docs will state what type the field is expected to be for such cases.  See podman-system-service(1) for more information.  Quick Examples:  'podman info'  curl --unix-socket /run/podman/podman.sock http://d/v5.0.0/libpod/info  'podman pull quay.io/containers/podman'  curl -XPOST --unix-socket /run/podman/podman.sock -v 'http://d/v5.0.0/images/create?fromImage=quay.io%2Fcontainers%2Fpodman'  'podman list images'  curl --unix-socket /run/podman/podman.sock -v 'http://d/v5.0.0/libpod/images/json' | jq
 *
 * The version of the OpenAPI document: 5.0.0
 * Contact: podman@lists.podman.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package io.github.alersrt.pod4j.openapi.api;

import io.github.alersrt.pod4j.openapi.ApiClient;
import io.github.alersrt.pod4j.openapi.ApiException;
import io.github.alersrt.pod4j.openapi.ApiResponse;
import io.github.alersrt.pod4j.openapi.Pair;

import io.github.alersrt.pod4j.openapi.model.ContainerCreateResponse;
import io.github.alersrt.pod4j.openapi.model.ContainerStats;
import io.github.alersrt.pod4j.openapi.model.ContainerTopOKBody;
import io.github.alersrt.pod4j.openapi.model.ContainersPruneReportLibpod;
import io.github.alersrt.pod4j.openapi.model.ErrorModel;
import java.io.File;
import io.github.alersrt.pod4j.openapi.model.HealthCheckResults;
import io.github.alersrt.pod4j.openapi.model.InspectContainerData;
import io.github.alersrt.pod4j.openapi.model.LibpodContainersRmReport;
import io.github.alersrt.pod4j.openapi.model.ListContainer;
import io.github.alersrt.pod4j.openapi.model.PlayKubeReport;
import io.github.alersrt.pod4j.openapi.model.SpecGenerator;
import io.github.alersrt.pod4j.openapi.model.UpdateEntities;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import jakarta.validation.constraints.*;
import jakarta.validation.Valid;

import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.net.http.HttpRequest;
import java.nio.channels.Channels;
import java.nio.channels.Pipe;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;

import java.util.ArrayList;
import java.util.StringJoiner;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-11-28T19:32:38.690938181+07:00[Asia/Barnaul]", comments = "Generator version: 7.7.0")
public class ContainersApi {
  private final HttpClient memberVarHttpClient;
  private final ObjectMapper memberVarObjectMapper;
  private final String memberVarBaseUri;
  private final Consumer<HttpRequest.Builder> memberVarInterceptor;
  private final Duration memberVarReadTimeout;
  private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;
  private final Consumer<HttpResponse<String>> memberVarAsyncResponseInterceptor;

  public ContainersApi() {
    this(new ApiClient());
  }

  public ContainersApi(ApiClient apiClient) {
    memberVarHttpClient = apiClient.getHttpClient();
    memberVarObjectMapper = apiClient.getObjectMapper();
    memberVarBaseUri = apiClient.getBaseUri();
    memberVarInterceptor = apiClient.getRequestInterceptor();
    memberVarReadTimeout = apiClient.getReadTimeout();
    memberVarResponseInterceptor = apiClient.getResponseInterceptor();
    memberVarAsyncResponseInterceptor = apiClient.getAsyncResponseInterceptor();
  }

  protected ApiException getApiException(String operationId, HttpResponse<InputStream> response) throws IOException {
    String body = response.body() == null ? null : new String(response.body().readAllBytes());
    String message = formatExceptionMessage(operationId, response.statusCode(), body);
    return new ApiException(response.statusCode(), message, response.headers(), body);
  }

  private String formatExceptionMessage(String operationId, int statusCode, String body) {
    if (body == null || body.isEmpty()) {
      body = "[no body]";
    }
    return operationId + " call failed with: " + statusCode + " - " + body;
  }

  /**
   * Attach to a container
   * Attach to a container to read its output or send it input. You can attach to the same container multiple times and you can reattach to containers that have been detached.  ### Hijacking  This endpoint hijacks the HTTP connection to transport &#x60;stdin&#x60;, &#x60;stdout&#x60;, and &#x60;stderr&#x60; on the same socket.  This is the response from the service for an attach request:  &#x60;&#x60;&#x60; HTTP/1.1 200 OK Content-Type: application/vnd.docker.raw-stream  [STREAM] &#x60;&#x60;&#x60;  After the headers and two new lines, the TCP connection can now be used for raw, bidirectional communication between the client and server.  To inform potential proxies about connection hijacking, the client can also optionally send connection upgrade headers.  For example, the client sends this request to upgrade the connection:  &#x60;&#x60;&#x60; POST /v4.6.0/libpod/containers/16253994b7c4/attach?stream&#x3D;1&amp;stdout&#x3D;1 HTTP/1.1 Upgrade: tcp Connection: Upgrade &#x60;&#x60;&#x60;  The service will respond with a &#x60;101 UPGRADED&#x60; response, and will similarly follow with the raw stream:  &#x60;&#x60;&#x60; HTTP/1.1 101 UPGRADED Content-Type: application/vnd.docker.raw-stream Connection: Upgrade Upgrade: tcp  [STREAM] &#x60;&#x60;&#x60;  ### Stream format  When the TTY setting is disabled for the container, the HTTP Content-Type header is set to application/vnd.docker.multiplexed-stream (starting with v4.7.0, previously application/vnd.docker.raw-stream was always used) and the stream over the hijacked connected is multiplexed to separate out &#x60;stdout&#x60; and &#x60;stderr&#x60;. The stream consists of a series of frames, each containing a header and a payload.  The header contains the information about the output stream type and the size of the payload. It is encoded on the first eight bytes like this:  &#x60;&#x60;&#x60;go header :&#x3D; [8]byte{STREAM_TYPE, 0, 0, 0, SIZE1, SIZE2, SIZE3, SIZE4} &#x60;&#x60;&#x60;  &#x60;STREAM_TYPE&#x60; can be:  - 0: &#x60;stdin&#x60; (is written on &#x60;stdout&#x60;) - 1: &#x60;stdout&#x60; - 2: &#x60;stderr&#x60;  &#x60;SIZE1, SIZE2, SIZE3, SIZE4&#x60; are the four bytes of the &#x60;uint32&#x60; size encoded as big endian.  Following the header is the payload, which contains the specified number of bytes as written in the size.  The simplest way to implement this protocol is the following:  1. Read 8 bytes. 2. Choose &#x60;stdout&#x60; or &#x60;stderr&#x60; depending on the first byte. 3. Extract the frame size from the last four bytes. 4. Read the extracted size and output it on the correct output. 5. Goto 1.  ### Stream format when using a TTY  When the TTY setting is enabled for the container, the stream is not multiplexed. The data exchanged over the hijacked connection is simply the raw data from the process PTY and client&#39;s &#x60;stdin&#x60;. 
   * @param name the name or ID of the container (required)
   * @param detachKeys keys to use for detaching from the container (optional)
   * @param logs Stream all logs from the container across the connection. Happens before streaming attach (if requested). At least one of logs or stream must be set (optional)
   * @param stream Attach to the container. If unset, and logs is set, only the container&#39;s logs will be sent. At least one of stream or logs must be set (optional, default to true)
   * @param stdout Attach to container STDOUT (optional)
   * @param stderr Attach to container STDERR (optional)
   * @param stdin Attach to container STDIN (optional)
   * @throws ApiException if fails to make API call
   */
  public void containerAttachLibpod(String name, String detachKeys, Boolean logs, Boolean stream, Boolean stdout, Boolean stderr, Boolean stdin) throws ApiException {
    containerAttachLibpodWithHttpInfo(name, detachKeys, logs, stream, stdout, stderr, stdin);
  }

  /**
   * Attach to a container
   * Attach to a container to read its output or send it input. You can attach to the same container multiple times and you can reattach to containers that have been detached.  ### Hijacking  This endpoint hijacks the HTTP connection to transport &#x60;stdin&#x60;, &#x60;stdout&#x60;, and &#x60;stderr&#x60; on the same socket.  This is the response from the service for an attach request:  &#x60;&#x60;&#x60; HTTP/1.1 200 OK Content-Type: application/vnd.docker.raw-stream  [STREAM] &#x60;&#x60;&#x60;  After the headers and two new lines, the TCP connection can now be used for raw, bidirectional communication between the client and server.  To inform potential proxies about connection hijacking, the client can also optionally send connection upgrade headers.  For example, the client sends this request to upgrade the connection:  &#x60;&#x60;&#x60; POST /v4.6.0/libpod/containers/16253994b7c4/attach?stream&#x3D;1&amp;stdout&#x3D;1 HTTP/1.1 Upgrade: tcp Connection: Upgrade &#x60;&#x60;&#x60;  The service will respond with a &#x60;101 UPGRADED&#x60; response, and will similarly follow with the raw stream:  &#x60;&#x60;&#x60; HTTP/1.1 101 UPGRADED Content-Type: application/vnd.docker.raw-stream Connection: Upgrade Upgrade: tcp  [STREAM] &#x60;&#x60;&#x60;  ### Stream format  When the TTY setting is disabled for the container, the HTTP Content-Type header is set to application/vnd.docker.multiplexed-stream (starting with v4.7.0, previously application/vnd.docker.raw-stream was always used) and the stream over the hijacked connected is multiplexed to separate out &#x60;stdout&#x60; and &#x60;stderr&#x60;. The stream consists of a series of frames, each containing a header and a payload.  The header contains the information about the output stream type and the size of the payload. It is encoded on the first eight bytes like this:  &#x60;&#x60;&#x60;go header :&#x3D; [8]byte{STREAM_TYPE, 0, 0, 0, SIZE1, SIZE2, SIZE3, SIZE4} &#x60;&#x60;&#x60;  &#x60;STREAM_TYPE&#x60; can be:  - 0: &#x60;stdin&#x60; (is written on &#x60;stdout&#x60;) - 1: &#x60;stdout&#x60; - 2: &#x60;stderr&#x60;  &#x60;SIZE1, SIZE2, SIZE3, SIZE4&#x60; are the four bytes of the &#x60;uint32&#x60; size encoded as big endian.  Following the header is the payload, which contains the specified number of bytes as written in the size.  The simplest way to implement this protocol is the following:  1. Read 8 bytes. 2. Choose &#x60;stdout&#x60; or &#x60;stderr&#x60; depending on the first byte. 3. Extract the frame size from the last four bytes. 4. Read the extracted size and output it on the correct output. 5. Goto 1.  ### Stream format when using a TTY  When the TTY setting is enabled for the container, the stream is not multiplexed. The data exchanged over the hijacked connection is simply the raw data from the process PTY and client&#39;s &#x60;stdin&#x60;. 
   * @param name the name or ID of the container (required)
   * @param detachKeys keys to use for detaching from the container (optional)
   * @param logs Stream all logs from the container across the connection. Happens before streaming attach (if requested). At least one of logs or stream must be set (optional)
   * @param stream Attach to the container. If unset, and logs is set, only the container&#39;s logs will be sent. At least one of stream or logs must be set (optional, default to true)
   * @param stdout Attach to container STDOUT (optional)
   * @param stderr Attach to container STDERR (optional)
   * @param stdin Attach to container STDIN (optional)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> containerAttachLibpodWithHttpInfo(String name, String detachKeys, Boolean logs, Boolean stream, Boolean stdout, Boolean stderr, Boolean stdin) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = containerAttachLibpodRequestBuilder(name, detachKeys, logs, stream, stdout, stderr, stdin);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("containerAttachLibpod", localVarResponse);
        }
        return new ApiResponse<Void>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
            // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder containerAttachLibpodRequestBuilder(String name, String detachKeys, Boolean logs, Boolean stream, Boolean stdout, Boolean stderr, Boolean stdin) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling containerAttachLibpod");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/containers/{name}/attach"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "detachKeys";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("detachKeys", detachKeys));
    localVarQueryParameterBaseName = "logs";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("logs", logs));
    localVarQueryParameterBaseName = "stream";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("stream", stream));
    localVarQueryParameterBaseName = "stdout";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("stdout", stdout));
    localVarQueryParameterBaseName = "stderr";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("stderr", stderr));
    localVarQueryParameterBaseName = "stdin";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("stdin", stdin));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Report on changes to container&#39;s filesystem; adds, deletes or modifications.
   * Returns which files in a container&#39;s filesystem have been added, deleted, or modified. The Kind of modification can be one of:  0: Modified 1: Added 2: Deleted 
   * @param name the name or id of the container (required)
   * @param parent specify a second layer which is used to compare against it instead of the parent layer (optional)
   * @param diffType select what you want to match, default is all (optional)
   * @throws ApiException if fails to make API call
   */
  public void containerChangesLibpod(String name, String parent, String diffType) throws ApiException {
    containerChangesLibpodWithHttpInfo(name, parent, diffType);
  }

  /**
   * Report on changes to container&#39;s filesystem; adds, deletes or modifications.
   * Returns which files in a container&#39;s filesystem have been added, deleted, or modified. The Kind of modification can be one of:  0: Modified 1: Added 2: Deleted 
   * @param name the name or id of the container (required)
   * @param parent specify a second layer which is used to compare against it instead of the parent layer (optional)
   * @param diffType select what you want to match, default is all (optional)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> containerChangesLibpodWithHttpInfo(String name, String parent, String diffType) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = containerChangesLibpodRequestBuilder(name, parent, diffType);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("containerChangesLibpod", localVarResponse);
        }
        return new ApiResponse<Void>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
            // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder containerChangesLibpodRequestBuilder(String name, String parent, String diffType) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling containerChangesLibpod");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/containers/{name}/changes"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "parent";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("parent", parent));
    localVarQueryParameterBaseName = "diffType";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("diffType", diffType));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json, application/octet-stream, text/plain");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Checkpoint a container
   * 
   * @param name the name or ID of the container (required)
   * @param keep keep all temporary checkpoint files (optional)
   * @param leaveRunning leave the container running after writing checkpoint to disk (optional)
   * @param tcpEstablished checkpoint a container with established TCP connections (optional)
   * @param export export the checkpoint image to a tar.gz (optional)
   * @param ignoreRootFS do not include root file-system changes when exporting. can only be used with export (optional)
   * @param ignoreVolumes do not include associated volumes. can only be used with export (optional)
   * @param preCheckpoint dump the container&#39;s memory information only, leaving the container running. only works on runc 1.0-rc or higher (optional)
   * @param withPrevious check out the container with previous criu image files in pre-dump. only works on runc 1.0-rc or higher (optional)
   * @param fileLocks checkpoint a container with filelocks (optional)
   * @param printStats add checkpoint statistics to the returned CheckpointReport (optional)
   * @throws ApiException if fails to make API call
   */
  public void containerCheckpointLibpod(String name, Boolean keep, Boolean leaveRunning, Boolean tcpEstablished, Boolean export, Boolean ignoreRootFS, Boolean ignoreVolumes, Boolean preCheckpoint, Boolean withPrevious, Boolean fileLocks, Boolean printStats) throws ApiException {
    containerCheckpointLibpodWithHttpInfo(name, keep, leaveRunning, tcpEstablished, export, ignoreRootFS, ignoreVolumes, preCheckpoint, withPrevious, fileLocks, printStats);
  }

  /**
   * Checkpoint a container
   * 
   * @param name the name or ID of the container (required)
   * @param keep keep all temporary checkpoint files (optional)
   * @param leaveRunning leave the container running after writing checkpoint to disk (optional)
   * @param tcpEstablished checkpoint a container with established TCP connections (optional)
   * @param export export the checkpoint image to a tar.gz (optional)
   * @param ignoreRootFS do not include root file-system changes when exporting. can only be used with export (optional)
   * @param ignoreVolumes do not include associated volumes. can only be used with export (optional)
   * @param preCheckpoint dump the container&#39;s memory information only, leaving the container running. only works on runc 1.0-rc or higher (optional)
   * @param withPrevious check out the container with previous criu image files in pre-dump. only works on runc 1.0-rc or higher (optional)
   * @param fileLocks checkpoint a container with filelocks (optional)
   * @param printStats add checkpoint statistics to the returned CheckpointReport (optional)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> containerCheckpointLibpodWithHttpInfo(String name, Boolean keep, Boolean leaveRunning, Boolean tcpEstablished, Boolean export, Boolean ignoreRootFS, Boolean ignoreVolumes, Boolean preCheckpoint, Boolean withPrevious, Boolean fileLocks, Boolean printStats) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = containerCheckpointLibpodRequestBuilder(name, keep, leaveRunning, tcpEstablished, export, ignoreRootFS, ignoreVolumes, preCheckpoint, withPrevious, fileLocks, printStats);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("containerCheckpointLibpod", localVarResponse);
        }
        return new ApiResponse<Void>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
            // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder containerCheckpointLibpodRequestBuilder(String name, Boolean keep, Boolean leaveRunning, Boolean tcpEstablished, Boolean export, Boolean ignoreRootFS, Boolean ignoreVolumes, Boolean preCheckpoint, Boolean withPrevious, Boolean fileLocks, Boolean printStats) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling containerCheckpointLibpod");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/containers/{name}/checkpoint"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "keep";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("keep", keep));
    localVarQueryParameterBaseName = "leaveRunning";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("leaveRunning", leaveRunning));
    localVarQueryParameterBaseName = "tcpEstablished";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("tcpEstablished", tcpEstablished));
    localVarQueryParameterBaseName = "export";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("export", export));
    localVarQueryParameterBaseName = "ignoreRootFS";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("ignoreRootFS", ignoreRootFS));
    localVarQueryParameterBaseName = "ignoreVolumes";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("ignoreVolumes", ignoreVolumes));
    localVarQueryParameterBaseName = "preCheckpoint";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("preCheckpoint", preCheckpoint));
    localVarQueryParameterBaseName = "withPrevious";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("withPrevious", withPrevious));
    localVarQueryParameterBaseName = "fileLocks";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("fileLocks", fileLocks));
    localVarQueryParameterBaseName = "printStats";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("printStats", printStats));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Create a container
   * 
   * @param create attributes for creating a container (required)
   * @return ContainerCreateResponse
   * @throws ApiException if fails to make API call
   */
  public ContainerCreateResponse containerCreateLibpod(SpecGenerator create) throws ApiException {
    ApiResponse<ContainerCreateResponse> localVarResponse = containerCreateLibpodWithHttpInfo(create);
    return localVarResponse.getData();
  }

  /**
   * Create a container
   * 
   * @param create attributes for creating a container (required)
   * @return ApiResponse&lt;ContainerCreateResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ContainerCreateResponse> containerCreateLibpodWithHttpInfo(SpecGenerator create) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = containerCreateLibpodRequestBuilder(create);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("containerCreateLibpod", localVarResponse);
        }
        return new ApiResponse<ContainerCreateResponse>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<ContainerCreateResponse>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder containerCreateLibpodRequestBuilder(SpecGenerator create) throws ApiException {
    // verify the required parameter 'create' is set
    if (create == null) {
      throw new ApiException(400, "Missing the required parameter 'create' when calling containerCreateLibpod");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/containers/create";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(create);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Delete container
   * Delete container
   * @param name the name or ID of the container (required)
   * @param depend additionally remove containers that depend on the container to be removed (optional)
   * @param force force stop container if running (optional)
   * @param ignore ignore errors when the container to be removed does not existxo (optional)
   * @param timeout number of seconds to wait before killing container when force removing (optional, default to 10)
   * @param v delete volumes (optional)
   * @return List&lt;LibpodContainersRmReport&gt;
   * @throws ApiException if fails to make API call
   */
  public List<LibpodContainersRmReport> containerDeleteLibpod(String name, Boolean depend, Boolean force, Boolean ignore, Integer timeout, Boolean v) throws ApiException {
    ApiResponse<List<LibpodContainersRmReport>> localVarResponse = containerDeleteLibpodWithHttpInfo(name, depend, force, ignore, timeout, v);
    return localVarResponse.getData();
  }

  /**
   * Delete container
   * Delete container
   * @param name the name or ID of the container (required)
   * @param depend additionally remove containers that depend on the container to be removed (optional)
   * @param force force stop container if running (optional)
   * @param ignore ignore errors when the container to be removed does not existxo (optional)
   * @param timeout number of seconds to wait before killing container when force removing (optional, default to 10)
   * @param v delete volumes (optional)
   * @return ApiResponse&lt;List&lt;LibpodContainersRmReport&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<List<LibpodContainersRmReport>> containerDeleteLibpodWithHttpInfo(String name, Boolean depend, Boolean force, Boolean ignore, Integer timeout, Boolean v) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = containerDeleteLibpodRequestBuilder(name, depend, force, ignore, timeout, v);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("containerDeleteLibpod", localVarResponse);
        }
        return new ApiResponse<List<LibpodContainersRmReport>>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<List<LibpodContainersRmReport>>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder containerDeleteLibpodRequestBuilder(String name, Boolean depend, Boolean force, Boolean ignore, Integer timeout, Boolean v) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling containerDeleteLibpod");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/containers/{name}"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "depend";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("depend", depend));
    localVarQueryParameterBaseName = "force";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("force", force));
    localVarQueryParameterBaseName = "ignore";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("ignore", ignore));
    localVarQueryParameterBaseName = "timeout";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("timeout", timeout));
    localVarQueryParameterBaseName = "v";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("v", v));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("DELETE", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Check if container exists
   * Quick way to determine if a container exists by name or ID
   * @param name the name or ID of the container (required)
   * @throws ApiException if fails to make API call
   */
  public void containerExistsLibpod(String name) throws ApiException {
    containerExistsLibpodWithHttpInfo(name);
  }

  /**
   * Check if container exists
   * Quick way to determine if a container exists by name or ID
   * @param name the name or ID of the container (required)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> containerExistsLibpodWithHttpInfo(String name) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = containerExistsLibpodRequestBuilder(name);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("containerExistsLibpod", localVarResponse);
        }
        return new ApiResponse<Void>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
            // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder containerExistsLibpodRequestBuilder(String name) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling containerExistsLibpod");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/containers/{name}/exists"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Export a container
   * Export the contents of a container as a tarball.
   * @param name the name or ID of the container (required)
   * @throws ApiException if fails to make API call
   */
  public void containerExportLibpod(String name) throws ApiException {
    containerExportLibpodWithHttpInfo(name);
  }

  /**
   * Export a container
   * Export the contents of a container as a tarball.
   * @param name the name or ID of the container (required)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> containerExportLibpodWithHttpInfo(String name) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = containerExportLibpodRequestBuilder(name);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("containerExportLibpod", localVarResponse);
        }
        return new ApiResponse<Void>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
            // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder containerExportLibpodRequestBuilder(String name) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling containerExportLibpod");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/containers/{name}/export"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Run a container&#39;s healthcheck
   * Execute the defined healthcheck and return information about the results
   * @param name the name or ID of the container (required)
   * @return HealthCheckResults
   * @throws ApiException if fails to make API call
   */
  public HealthCheckResults containerHealthcheckLibpod(String name) throws ApiException {
    ApiResponse<HealthCheckResults> localVarResponse = containerHealthcheckLibpodWithHttpInfo(name);
    return localVarResponse.getData();
  }

  /**
   * Run a container&#39;s healthcheck
   * Execute the defined healthcheck and return information about the results
   * @param name the name or ID of the container (required)
   * @return ApiResponse&lt;HealthCheckResults&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<HealthCheckResults> containerHealthcheckLibpodWithHttpInfo(String name) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = containerHealthcheckLibpodRequestBuilder(name);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("containerHealthcheckLibpod", localVarResponse);
        }
        return new ApiResponse<HealthCheckResults>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<HealthCheckResults>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder containerHealthcheckLibpodRequestBuilder(String name) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling containerHealthcheckLibpod");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/containers/{name}/healthcheck"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Initialize a container
   * Performs all tasks necessary for initializing the container but does not start the container.
   * @param name the name or ID of the container (required)
   * @throws ApiException if fails to make API call
   */
  public void containerInitLibpod(String name) throws ApiException {
    containerInitLibpodWithHttpInfo(name);
  }

  /**
   * Initialize a container
   * Performs all tasks necessary for initializing the container but does not start the container.
   * @param name the name or ID of the container (required)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> containerInitLibpodWithHttpInfo(String name) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = containerInitLibpodRequestBuilder(name);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("containerInitLibpod", localVarResponse);
        }
        return new ApiResponse<Void>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
            // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder containerInitLibpodRequestBuilder(String name) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling containerInitLibpod");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/containers/{name}/init"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Inspect container
   * Return low-level information about a container.
   * @param name the name or ID of the container (required)
   * @param size display filesystem usage (optional)
   * @return InspectContainerData
   * @throws ApiException if fails to make API call
   */
  public InspectContainerData containerInspectLibpod(String name, Boolean size) throws ApiException {
    ApiResponse<InspectContainerData> localVarResponse = containerInspectLibpodWithHttpInfo(name, size);
    return localVarResponse.getData();
  }

  /**
   * Inspect container
   * Return low-level information about a container.
   * @param name the name or ID of the container (required)
   * @param size display filesystem usage (optional)
   * @return ApiResponse&lt;InspectContainerData&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<InspectContainerData> containerInspectLibpodWithHttpInfo(String name, Boolean size) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = containerInspectLibpodRequestBuilder(name, size);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("containerInspectLibpod", localVarResponse);
        }
        return new ApiResponse<InspectContainerData>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<InspectContainerData>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder containerInspectLibpodRequestBuilder(String name, Boolean size) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling containerInspectLibpod");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/containers/{name}/json"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "size";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("size", size));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Kill container
   * send a signal to a container, defaults to killing the container
   * @param name the name or ID of the container (required)
   * @param signal signal to be sent to container, either by integer or SIG_ name (optional, default to SIGKILL)
   * @throws ApiException if fails to make API call
   */
  public void containerKillLibpod(String name, String signal) throws ApiException {
    containerKillLibpodWithHttpInfo(name, signal);
  }

  /**
   * Kill container
   * send a signal to a container, defaults to killing the container
   * @param name the name or ID of the container (required)
   * @param signal signal to be sent to container, either by integer or SIG_ name (optional, default to SIGKILL)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> containerKillLibpodWithHttpInfo(String name, String signal) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = containerKillLibpodRequestBuilder(name, signal);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("containerKillLibpod", localVarResponse);
        }
        return new ApiResponse<Void>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
            // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder containerKillLibpodRequestBuilder(String name, String signal) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling containerKillLibpod");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/containers/{name}/kill"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "signal";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("signal", signal));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * List containers
   * Returns a list of containers
   * @param all Return all containers. By default, only running containers are shown (optional, default to false)
   * @param limit Return this number of most recently created containers, including non-running ones. (optional)
   * @param namespace Include namespace information (optional, default to false)
   * @param pod Ignored. Previously included details on pod name and ID that are currently included by default. (optional, default to false)
   * @param size Return the size of container as fields SizeRw and SizeRootFs. (optional, default to false)
   * @param sync Sync container state with OCI runtime (optional, default to false)
   * @param filters A JSON encoded value of the filters (a &#x60;map[string][]string&#x60;) to process on the containers list. Available filters: - &#x60;ancestor&#x60;&#x3D;(&#x60;&lt;image-name&gt;[:&lt;tag&gt;]&#x60;, &#x60;&lt;image id&gt;&#x60;, or &#x60;&lt;image@digest&gt;&#x60;) - &#x60;before&#x60;&#x3D;(&#x60;&lt;container id&gt;&#x60; or &#x60;&lt;container name&gt;&#x60;) - &#x60;expose&#x60;&#x3D;(&#x60;&lt;port&gt;[/&lt;proto&gt;]&#x60; or &#x60;&lt;startport-endport&gt;/[&lt;proto&gt;]&#x60;) - &#x60;exited&#x3D;&lt;int&gt;&#x60; containers with exit code of &#x60;&lt;int&gt;&#x60; - &#x60;health&#x60;&#x3D;(&#x60;starting&#x60;, &#x60;healthy&#x60;, &#x60;unhealthy&#x60; or &#x60;none&#x60;) - &#x60;id&#x3D;&lt;ID&gt;&#x60; a container&#39;s ID - &#x60;is-task&#x60;&#x3D;(&#x60;true&#x60; or &#x60;false&#x60;) - &#x60;label&#x60;&#x3D;(&#x60;key&#x60; or &#x60;\&quot;key&#x3D;value\&quot;&#x60;) of a container label - &#x60;name&#x3D;&lt;name&gt;&#x60; a container&#39;s name - &#x60;network&#x60;&#x3D;(&#x60;&lt;network id&gt;&#x60; or &#x60;&lt;network name&gt;&#x60;) - &#x60;pod&#x60;&#x3D;(&#x60;&lt;pod id&gt;&#x60; or &#x60;&lt;pod name&gt;&#x60;) - &#x60;publish&#x60;&#x3D;(&#x60;&lt;port&gt;[/&lt;proto&gt;]&#x60; or &#x60;&lt;startport-endport&gt;/[&lt;proto&gt;]&#x60;) - &#x60;since&#x60;&#x3D;(&#x60;&lt;container id&gt;&#x60; or &#x60;&lt;container name&gt;&#x60;) - &#x60;status&#x60;&#x3D;(&#x60;created&#x60;, &#x60;restarting&#x60;, &#x60;running&#x60;, &#x60;removing&#x60;, &#x60;paused&#x60;, &#x60;exited&#x60; or &#x60;dead&#x60;) - &#x60;volume&#x60;&#x3D;(&#x60;&lt;volume name&gt;&#x60; or &#x60;&lt;mount point destination&gt;&#x60;)  (optional)
   * @return List&lt;ListContainer&gt;
   * @throws ApiException if fails to make API call
   */
  public List<ListContainer> containerListLibpod(Boolean all, Integer limit, Boolean namespace, Boolean pod, Boolean size, Boolean sync, String filters) throws ApiException {
    ApiResponse<List<ListContainer>> localVarResponse = containerListLibpodWithHttpInfo(all, limit, namespace, pod, size, sync, filters);
    return localVarResponse.getData();
  }

  /**
   * List containers
   * Returns a list of containers
   * @param all Return all containers. By default, only running containers are shown (optional, default to false)
   * @param limit Return this number of most recently created containers, including non-running ones. (optional)
   * @param namespace Include namespace information (optional, default to false)
   * @param pod Ignored. Previously included details on pod name and ID that are currently included by default. (optional, default to false)
   * @param size Return the size of container as fields SizeRw and SizeRootFs. (optional, default to false)
   * @param sync Sync container state with OCI runtime (optional, default to false)
   * @param filters A JSON encoded value of the filters (a &#x60;map[string][]string&#x60;) to process on the containers list. Available filters: - &#x60;ancestor&#x60;&#x3D;(&#x60;&lt;image-name&gt;[:&lt;tag&gt;]&#x60;, &#x60;&lt;image id&gt;&#x60;, or &#x60;&lt;image@digest&gt;&#x60;) - &#x60;before&#x60;&#x3D;(&#x60;&lt;container id&gt;&#x60; or &#x60;&lt;container name&gt;&#x60;) - &#x60;expose&#x60;&#x3D;(&#x60;&lt;port&gt;[/&lt;proto&gt;]&#x60; or &#x60;&lt;startport-endport&gt;/[&lt;proto&gt;]&#x60;) - &#x60;exited&#x3D;&lt;int&gt;&#x60; containers with exit code of &#x60;&lt;int&gt;&#x60; - &#x60;health&#x60;&#x3D;(&#x60;starting&#x60;, &#x60;healthy&#x60;, &#x60;unhealthy&#x60; or &#x60;none&#x60;) - &#x60;id&#x3D;&lt;ID&gt;&#x60; a container&#39;s ID - &#x60;is-task&#x60;&#x3D;(&#x60;true&#x60; or &#x60;false&#x60;) - &#x60;label&#x60;&#x3D;(&#x60;key&#x60; or &#x60;\&quot;key&#x3D;value\&quot;&#x60;) of a container label - &#x60;name&#x3D;&lt;name&gt;&#x60; a container&#39;s name - &#x60;network&#x60;&#x3D;(&#x60;&lt;network id&gt;&#x60; or &#x60;&lt;network name&gt;&#x60;) - &#x60;pod&#x60;&#x3D;(&#x60;&lt;pod id&gt;&#x60; or &#x60;&lt;pod name&gt;&#x60;) - &#x60;publish&#x60;&#x3D;(&#x60;&lt;port&gt;[/&lt;proto&gt;]&#x60; or &#x60;&lt;startport-endport&gt;/[&lt;proto&gt;]&#x60;) - &#x60;since&#x60;&#x3D;(&#x60;&lt;container id&gt;&#x60; or &#x60;&lt;container name&gt;&#x60;) - &#x60;status&#x60;&#x3D;(&#x60;created&#x60;, &#x60;restarting&#x60;, &#x60;running&#x60;, &#x60;removing&#x60;, &#x60;paused&#x60;, &#x60;exited&#x60; or &#x60;dead&#x60;) - &#x60;volume&#x60;&#x3D;(&#x60;&lt;volume name&gt;&#x60; or &#x60;&lt;mount point destination&gt;&#x60;)  (optional)
   * @return ApiResponse&lt;List&lt;ListContainer&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<List<ListContainer>> containerListLibpodWithHttpInfo(Boolean all, Integer limit, Boolean namespace, Boolean pod, Boolean size, Boolean sync, String filters) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = containerListLibpodRequestBuilder(all, limit, namespace, pod, size, sync, filters);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("containerListLibpod", localVarResponse);
        }
        return new ApiResponse<List<ListContainer>>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<List<ListContainer>>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder containerListLibpodRequestBuilder(Boolean all, Integer limit, Boolean namespace, Boolean pod, Boolean size, Boolean sync, String filters) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/containers/json";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "all";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("all", all));
    localVarQueryParameterBaseName = "limit";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit", limit));
    localVarQueryParameterBaseName = "namespace";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("namespace", namespace));
    localVarQueryParameterBaseName = "pod";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("pod", pod));
    localVarQueryParameterBaseName = "size";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("size", size));
    localVarQueryParameterBaseName = "sync";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("sync", sync));
    localVarQueryParameterBaseName = "filters";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("filters", filters));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Get container logs
   * Get stdout and stderr logs from a container.  The stream format is the same as described in the attach endpoint. 
   * @param name the name or ID of the container (required)
   * @param follow Keep connection after returning logs. (optional)
   * @param stdout Return logs from stdout (optional)
   * @param stderr Return logs from stderr (optional)
   * @param since Only return logs since this time, as a UNIX timestamp (optional)
   * @param until Only return logs before this time, as a UNIX timestamp (optional)
   * @param timestamps Add timestamps to every log line (optional, default to false)
   * @param tail Only return this number of log lines from the end of the logs (optional, default to all)
   * @throws ApiException if fails to make API call
   */
  public void containerLogsLibpod(String name, Boolean follow, Boolean stdout, Boolean stderr, String since, String until, Boolean timestamps, String tail) throws ApiException {
    containerLogsLibpodWithHttpInfo(name, follow, stdout, stderr, since, until, timestamps, tail);
  }

  /**
   * Get container logs
   * Get stdout and stderr logs from a container.  The stream format is the same as described in the attach endpoint. 
   * @param name the name or ID of the container (required)
   * @param follow Keep connection after returning logs. (optional)
   * @param stdout Return logs from stdout (optional)
   * @param stderr Return logs from stderr (optional)
   * @param since Only return logs since this time, as a UNIX timestamp (optional)
   * @param until Only return logs before this time, as a UNIX timestamp (optional)
   * @param timestamps Add timestamps to every log line (optional, default to false)
   * @param tail Only return this number of log lines from the end of the logs (optional, default to all)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> containerLogsLibpodWithHttpInfo(String name, Boolean follow, Boolean stdout, Boolean stderr, String since, String until, Boolean timestamps, String tail) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = containerLogsLibpodRequestBuilder(name, follow, stdout, stderr, since, until, timestamps, tail);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("containerLogsLibpod", localVarResponse);
        }
        return new ApiResponse<Void>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
            // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder containerLogsLibpodRequestBuilder(String name, Boolean follow, Boolean stdout, Boolean stderr, String since, String until, Boolean timestamps, String tail) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling containerLogsLibpod");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/containers/{name}/logs"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "follow";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("follow", follow));
    localVarQueryParameterBaseName = "stdout";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("stdout", stdout));
    localVarQueryParameterBaseName = "stderr";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("stderr", stderr));
    localVarQueryParameterBaseName = "since";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("since", since));
    localVarQueryParameterBaseName = "until";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("until", until));
    localVarQueryParameterBaseName = "timestamps";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("timestamps", timestamps));
    localVarQueryParameterBaseName = "tail";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("tail", tail));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Mount a container
   * Mount a container to the filesystem
   * @param name the name or ID of the container (required)
   * @return String
   * @throws ApiException if fails to make API call
   */
  public String containerMountLibpod(String name) throws ApiException {
    ApiResponse<String> localVarResponse = containerMountLibpodWithHttpInfo(name);
    return localVarResponse.getData();
  }

  /**
   * Mount a container
   * Mount a container to the filesystem
   * @param name the name or ID of the container (required)
   * @return ApiResponse&lt;String&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<String> containerMountLibpodWithHttpInfo(String name) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = containerMountLibpodRequestBuilder(name);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("containerMountLibpod", localVarResponse);
        }
        return new ApiResponse<String>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<String>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder containerMountLibpodRequestBuilder(String name) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling containerMountLibpod");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/containers/{name}/mount"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Pause a container
   * Use the cgroups freezer to suspend all processes in a container.
   * @param name the name or ID of the container (required)
   * @throws ApiException if fails to make API call
   */
  public void containerPauseLibpod(String name) throws ApiException {
    containerPauseLibpodWithHttpInfo(name);
  }

  /**
   * Pause a container
   * Use the cgroups freezer to suspend all processes in a container.
   * @param name the name or ID of the container (required)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> containerPauseLibpodWithHttpInfo(String name) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = containerPauseLibpodRequestBuilder(name);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("containerPauseLibpod", localVarResponse);
        }
        return new ApiResponse<Void>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
            // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder containerPauseLibpodRequestBuilder(String name) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling containerPauseLibpod");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/containers/{name}/pause"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Delete stopped containers
   * Remove containers not in use
   * @param filters Filters to process on the prune list, encoded as JSON (a &#x60;map[string][]string&#x60;).  Available filters:  - &#x60;until&#x3D;&lt;timestamp&gt;&#x60; Prune containers created before this timestamp. The &#x60;&lt;timestamp&gt;&#x60; can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. &#x60;10m&#x60;, &#x60;1h30m&#x60;) computed relative to the daemon machineâ€™s time.  - &#x60;label&#x60; (&#x60;label&#x3D;&lt;key&gt;&#x60;, &#x60;label&#x3D;&lt;key&gt;&#x3D;&lt;value&gt;&#x60;, &#x60;label!&#x3D;&lt;key&gt;&#x60;, or &#x60;label!&#x3D;&lt;key&gt;&#x3D;&lt;value&gt;&#x60;) Prune containers with (or without, in case &#x60;label!&#x3D;...&#x60; is used) the specified labels.  (optional)
   * @return List&lt;ContainersPruneReportLibpod&gt;
   * @throws ApiException if fails to make API call
   */
  public List<ContainersPruneReportLibpod> containerPruneLibpod(String filters) throws ApiException {
    ApiResponse<List<ContainersPruneReportLibpod>> localVarResponse = containerPruneLibpodWithHttpInfo(filters);
    return localVarResponse.getData();
  }

  /**
   * Delete stopped containers
   * Remove containers not in use
   * @param filters Filters to process on the prune list, encoded as JSON (a &#x60;map[string][]string&#x60;).  Available filters:  - &#x60;until&#x3D;&lt;timestamp&gt;&#x60; Prune containers created before this timestamp. The &#x60;&lt;timestamp&gt;&#x60; can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. &#x60;10m&#x60;, &#x60;1h30m&#x60;) computed relative to the daemon machineâ€™s time.  - &#x60;label&#x60; (&#x60;label&#x3D;&lt;key&gt;&#x60;, &#x60;label&#x3D;&lt;key&gt;&#x3D;&lt;value&gt;&#x60;, &#x60;label!&#x3D;&lt;key&gt;&#x60;, or &#x60;label!&#x3D;&lt;key&gt;&#x3D;&lt;value&gt;&#x60;) Prune containers with (or without, in case &#x60;label!&#x3D;...&#x60; is used) the specified labels.  (optional)
   * @return ApiResponse&lt;List&lt;ContainersPruneReportLibpod&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<List<ContainersPruneReportLibpod>> containerPruneLibpodWithHttpInfo(String filters) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = containerPruneLibpodRequestBuilder(filters);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("containerPruneLibpod", localVarResponse);
        }
        return new ApiResponse<List<ContainersPruneReportLibpod>>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<List<ContainersPruneReportLibpod>>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder containerPruneLibpodRequestBuilder(String filters) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/containers/prune";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "filters";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("filters", filters));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Rename an existing container
   * Change the name of an existing container.
   * @param name Full or partial ID or full name of the container to rename (required)
   * @param name2 New name for the container (required)
   * @throws ApiException if fails to make API call
   */
  public void containerRenameLibpod(String name, String name2) throws ApiException {
    containerRenameLibpodWithHttpInfo(name, name2);
  }

  /**
   * Rename an existing container
   * Change the name of an existing container.
   * @param name Full or partial ID or full name of the container to rename (required)
   * @param name2 New name for the container (required)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> containerRenameLibpodWithHttpInfo(String name, String name2) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = containerRenameLibpodRequestBuilder(name, name2);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("containerRenameLibpod", localVarResponse);
        }
        return new ApiResponse<Void>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
            // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder containerRenameLibpodRequestBuilder(String name, String name2) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling containerRenameLibpod");
    }
    // verify the required parameter 'name2' is set
    if (name2 == null) {
      throw new ApiException(400, "Missing the required parameter 'name2' when calling containerRenameLibpod");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/containers/{name}/rename"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "name";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("name", name2));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Resize a container&#39;s TTY
   * Resize the terminal attached to a container (for use with Attach).
   * @param name the name or ID of the container (required)
   * @param h Height to set for the terminal, in characters (optional)
   * @param w Width to set for the terminal, in characters (optional)
   * @return Object
   * @throws ApiException if fails to make API call
   */
  public Object containerResizeLibpod(String name, Integer h, Integer w) throws ApiException {
    ApiResponse<Object> localVarResponse = containerResizeLibpodWithHttpInfo(name, h, w);
    return localVarResponse.getData();
  }

  /**
   * Resize a container&#39;s TTY
   * Resize the terminal attached to a container (for use with Attach).
   * @param name the name or ID of the container (required)
   * @param h Height to set for the terminal, in characters (optional)
   * @param w Width to set for the terminal, in characters (optional)
   * @return ApiResponse&lt;Object&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Object> containerResizeLibpodWithHttpInfo(String name, Integer h, Integer w) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = containerResizeLibpodRequestBuilder(name, h, w);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("containerResizeLibpod", localVarResponse);
        }
        return new ApiResponse<Object>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<Object>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder containerResizeLibpodRequestBuilder(String name, Integer h, Integer w) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling containerResizeLibpod");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/containers/{name}/resize"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "h";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("h", h));
    localVarQueryParameterBaseName = "w";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("w", w));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Restart a container
   * 
   * @param name the name or ID of the container (required)
   * @param t number of seconds to wait before killing container (optional, default to 10)
   * @throws ApiException if fails to make API call
   */
  public void containerRestartLibpod(String name, Integer t) throws ApiException {
    containerRestartLibpodWithHttpInfo(name, t);
  }

  /**
   * Restart a container
   * 
   * @param name the name or ID of the container (required)
   * @param t number of seconds to wait before killing container (optional, default to 10)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> containerRestartLibpodWithHttpInfo(String name, Integer t) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = containerRestartLibpodRequestBuilder(name, t);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("containerRestartLibpod", localVarResponse);
        }
        return new ApiResponse<Void>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
            // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder containerRestartLibpodRequestBuilder(String name, Integer t) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling containerRestartLibpod");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/containers/{name}/restart"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "t";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("t", t));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Restore a container
   * Restore a container from a checkpoint.
   * @param name the name or id of the container (required)
   * @param name2 the name of the container when restored from a tar. can only be used with import (optional)
   * @param keep keep all temporary checkpoint files (optional)
   * @param tcpEstablished checkpoint a container with established TCP connections (optional)
   * @param _import import the restore from a checkpoint tar.gz (optional)
   * @param ignoreRootFS do not include root file-system changes when exporting. can only be used with import (optional)
   * @param ignoreVolumes do not restore associated volumes. can only be used with import (optional)
   * @param ignoreStaticIP ignore IP address if set statically (optional)
   * @param ignoreStaticMAC ignore MAC address if set statically (optional)
   * @param fileLocks restore a container with file locks (optional)
   * @param printStats add restore statistics to the returned RestoreReport (optional)
   * @param pod pod to restore into (optional)
   * @throws ApiException if fails to make API call
   */
  public void containerRestoreLibpod(String name, String name2, Boolean keep, Boolean tcpEstablished, Boolean _import, Boolean ignoreRootFS, Boolean ignoreVolumes, Boolean ignoreStaticIP, Boolean ignoreStaticMAC, Boolean fileLocks, Boolean printStats, String pod) throws ApiException {
    containerRestoreLibpodWithHttpInfo(name, name2, keep, tcpEstablished, _import, ignoreRootFS, ignoreVolumes, ignoreStaticIP, ignoreStaticMAC, fileLocks, printStats, pod);
  }

  /**
   * Restore a container
   * Restore a container from a checkpoint.
   * @param name the name or id of the container (required)
   * @param name2 the name of the container when restored from a tar. can only be used with import (optional)
   * @param keep keep all temporary checkpoint files (optional)
   * @param tcpEstablished checkpoint a container with established TCP connections (optional)
   * @param _import import the restore from a checkpoint tar.gz (optional)
   * @param ignoreRootFS do not include root file-system changes when exporting. can only be used with import (optional)
   * @param ignoreVolumes do not restore associated volumes. can only be used with import (optional)
   * @param ignoreStaticIP ignore IP address if set statically (optional)
   * @param ignoreStaticMAC ignore MAC address if set statically (optional)
   * @param fileLocks restore a container with file locks (optional)
   * @param printStats add restore statistics to the returned RestoreReport (optional)
   * @param pod pod to restore into (optional)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> containerRestoreLibpodWithHttpInfo(String name, String name2, Boolean keep, Boolean tcpEstablished, Boolean _import, Boolean ignoreRootFS, Boolean ignoreVolumes, Boolean ignoreStaticIP, Boolean ignoreStaticMAC, Boolean fileLocks, Boolean printStats, String pod) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = containerRestoreLibpodRequestBuilder(name, name2, keep, tcpEstablished, _import, ignoreRootFS, ignoreVolumes, ignoreStaticIP, ignoreStaticMAC, fileLocks, printStats, pod);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("containerRestoreLibpod", localVarResponse);
        }
        return new ApiResponse<Void>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
            // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder containerRestoreLibpodRequestBuilder(String name, String name2, Boolean keep, Boolean tcpEstablished, Boolean _import, Boolean ignoreRootFS, Boolean ignoreVolumes, Boolean ignoreStaticIP, Boolean ignoreStaticMAC, Boolean fileLocks, Boolean printStats, String pod) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling containerRestoreLibpod");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/containers/{name}/restore"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "name";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("name", name2));
    localVarQueryParameterBaseName = "keep";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("keep", keep));
    localVarQueryParameterBaseName = "tcpEstablished";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("tcpEstablished", tcpEstablished));
    localVarQueryParameterBaseName = "import";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("import", _import));
    localVarQueryParameterBaseName = "ignoreRootFS";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("ignoreRootFS", ignoreRootFS));
    localVarQueryParameterBaseName = "ignoreVolumes";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("ignoreVolumes", ignoreVolumes));
    localVarQueryParameterBaseName = "ignoreStaticIP";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("ignoreStaticIP", ignoreStaticIP));
    localVarQueryParameterBaseName = "ignoreStaticMAC";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("ignoreStaticMAC", ignoreStaticMAC));
    localVarQueryParameterBaseName = "fileLocks";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("fileLocks", fileLocks));
    localVarQueryParameterBaseName = "printStats";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("printStats", printStats));
    localVarQueryParameterBaseName = "pod";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("pod", pod));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Show mounted containers
   * Lists all mounted containers mount points
   * @return Map&lt;String, String&gt;
   * @throws ApiException if fails to make API call
   */
  public Map<String, String> containerShowMountedLibpod() throws ApiException {
    ApiResponse<Map<String, String>> localVarResponse = containerShowMountedLibpodWithHttpInfo();
    return localVarResponse.getData();
  }

  /**
   * Show mounted containers
   * Lists all mounted containers mount points
   * @return ApiResponse&lt;Map&lt;String, String&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Map<String, String>> containerShowMountedLibpodWithHttpInfo() throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = containerShowMountedLibpodRequestBuilder();
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("containerShowMountedLibpod", localVarResponse);
        }
        return new ApiResponse<Map<String, String>>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<Map<String, String>>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder containerShowMountedLibpodRequestBuilder() throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/containers/showmounted";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Start a container
   * 
   * @param name the name or ID of the container (required)
   * @param detachKeys Override the key sequence for detaching a container. Format is a single character [a-Z] or ctrl-&lt;value&gt; where &lt;value&gt; is one of: a-z, @, ^, [, , or _. (optional, default to ctrl-p,ctrl-q)
   * @throws ApiException if fails to make API call
   */
  public void containerStartLibpod(String name, String detachKeys) throws ApiException {
    containerStartLibpodWithHttpInfo(name, detachKeys);
  }

  /**
   * Start a container
   * 
   * @param name the name or ID of the container (required)
   * @param detachKeys Override the key sequence for detaching a container. Format is a single character [a-Z] or ctrl-&lt;value&gt; where &lt;value&gt; is one of: a-z, @, ^, [, , or _. (optional, default to ctrl-p,ctrl-q)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> containerStartLibpodWithHttpInfo(String name, String detachKeys) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = containerStartLibpodRequestBuilder(name, detachKeys);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("containerStartLibpod", localVarResponse);
        }
        return new ApiResponse<Void>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
            // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder containerStartLibpodRequestBuilder(String name, String detachKeys) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling containerStartLibpod");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/containers/{name}/start"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "detachKeys";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("detachKeys", detachKeys));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Get stats for a container
   * DEPRECATED. This endpoint will be removed with the next major release. Please use /libpod/containers/stats instead.
   * @param name the name or ID of the container (required)
   * @param stream Stream the output (optional, default to true)
   * @throws ApiException if fails to make API call
   */
  public void containerStatsLibpod(String name, Boolean stream) throws ApiException {
    containerStatsLibpodWithHttpInfo(name, stream);
  }

  /**
   * Get stats for a container
   * DEPRECATED. This endpoint will be removed with the next major release. Please use /libpod/containers/stats instead.
   * @param name the name or ID of the container (required)
   * @param stream Stream the output (optional, default to true)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> containerStatsLibpodWithHttpInfo(String name, Boolean stream) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = containerStatsLibpodRequestBuilder(name, stream);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("containerStatsLibpod", localVarResponse);
        }
        return new ApiResponse<Void>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
            // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder containerStatsLibpodRequestBuilder(String name, Boolean stream) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling containerStatsLibpod");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/containers/{name}/stats"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "stream";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("stream", stream));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Stop a container
   * 
   * @param name the name or ID of the container (required)
   * @param timeout number of seconds to wait before killing container (optional, default to 10)
   * @param ignore do not return error if container is already stopped (optional, default to false)
   * @throws ApiException if fails to make API call
   */
  public void containerStopLibpod(String name, Integer timeout, Boolean ignore) throws ApiException {
    containerStopLibpodWithHttpInfo(name, timeout, ignore);
  }

  /**
   * Stop a container
   * 
   * @param name the name or ID of the container (required)
   * @param timeout number of seconds to wait before killing container (optional, default to 10)
   * @param ignore do not return error if container is already stopped (optional, default to false)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> containerStopLibpodWithHttpInfo(String name, Integer timeout, Boolean ignore) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = containerStopLibpodRequestBuilder(name, timeout, ignore);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("containerStopLibpod", localVarResponse);
        }
        return new ApiResponse<Void>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
            // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder containerStopLibpodRequestBuilder(String name, Integer timeout, Boolean ignore) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling containerStopLibpod");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/containers/{name}/stop"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "timeout";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("timeout", timeout));
    localVarQueryParameterBaseName = "Ignore";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("Ignore", ignore));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * List processes
   * List processes running inside a container
   * @param name Name of container to query for processes (As of version 1.xx) (required)
   * @param stream when true, repeatedly stream the latest output (As of version 4.0) (optional)
   * @param delay if streaming, delay in seconds between updates. Must be &gt;1. (As of version 4.0) (optional, default to 5)
   * @param psArgs arguments to pass to ps such as aux.  (optional)
   * @return ContainerTopOKBody
   * @throws ApiException if fails to make API call
   */
  public ContainerTopOKBody containerTopLibpod(String name, Boolean stream, Integer delay, List<String> psArgs) throws ApiException {
    ApiResponse<ContainerTopOKBody> localVarResponse = containerTopLibpodWithHttpInfo(name, stream, delay, psArgs);
    return localVarResponse.getData();
  }

  /**
   * List processes
   * List processes running inside a container
   * @param name Name of container to query for processes (As of version 1.xx) (required)
   * @param stream when true, repeatedly stream the latest output (As of version 4.0) (optional)
   * @param delay if streaming, delay in seconds between updates. Must be &gt;1. (As of version 4.0) (optional, default to 5)
   * @param psArgs arguments to pass to ps such as aux.  (optional)
   * @return ApiResponse&lt;ContainerTopOKBody&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ContainerTopOKBody> containerTopLibpodWithHttpInfo(String name, Boolean stream, Integer delay, List<String> psArgs) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = containerTopLibpodRequestBuilder(name, stream, delay, psArgs);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("containerTopLibpod", localVarResponse);
        }
        return new ApiResponse<ContainerTopOKBody>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<ContainerTopOKBody>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder containerTopLibpodRequestBuilder(String name, Boolean stream, Integer delay, List<String> psArgs) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling containerTopLibpod");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/containers/{name}/top"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "stream";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("stream", stream));
    localVarQueryParameterBaseName = "delay";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("delay", delay));
    localVarQueryParameterBaseName = "ps_args";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "ps_args", psArgs));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Unmount a container
   * Unmount a container from the filesystem
   * @param name the name or ID of the container (required)
   * @throws ApiException if fails to make API call
   */
  public void containerUnmountLibpod(String name) throws ApiException {
    containerUnmountLibpodWithHttpInfo(name);
  }

  /**
   * Unmount a container
   * Unmount a container from the filesystem
   * @param name the name or ID of the container (required)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> containerUnmountLibpodWithHttpInfo(String name) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = containerUnmountLibpodRequestBuilder(name);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("containerUnmountLibpod", localVarResponse);
        }
        return new ApiResponse<Void>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
            // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder containerUnmountLibpodRequestBuilder(String name) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling containerUnmountLibpod");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/containers/{name}/unmount"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Unpause Container
   * 
   * @param name the name or ID of the container (required)
   * @throws ApiException if fails to make API call
   */
  public void containerUnpauseLibpod(String name) throws ApiException {
    containerUnpauseLibpodWithHttpInfo(name);
  }

  /**
   * Unpause Container
   * 
   * @param name the name or ID of the container (required)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> containerUnpauseLibpodWithHttpInfo(String name) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = containerUnpauseLibpodRequestBuilder(name);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("containerUnpauseLibpod", localVarResponse);
        }
        return new ApiResponse<Void>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
            // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder containerUnpauseLibpodRequestBuilder(String name) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling containerUnpauseLibpod");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/containers/{name}/unpause"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Update an existing containers cgroup configuration
   * Update an existing containers cgroup configuration.
   * @param name Full or partial ID or full name of the container to update (required)
   * @param restartPolicy New restart policy for the container. (optional)
   * @param restartRetries New amount of retries for the container&#39;s restart policy. Only allowed if restartPolicy is set to on-failure (optional)
   * @param config attributes for updating the container (optional)
   * @throws ApiException if fails to make API call
   */
  public void containerUpdateLibpod(String name, String restartPolicy, Integer restartRetries, UpdateEntities config) throws ApiException {
    containerUpdateLibpodWithHttpInfo(name, restartPolicy, restartRetries, config);
  }

  /**
   * Update an existing containers cgroup configuration
   * Update an existing containers cgroup configuration.
   * @param name Full or partial ID or full name of the container to update (required)
   * @param restartPolicy New restart policy for the container. (optional)
   * @param restartRetries New amount of retries for the container&#39;s restart policy. Only allowed if restartPolicy is set to on-failure (optional)
   * @param config attributes for updating the container (optional)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> containerUpdateLibpodWithHttpInfo(String name, String restartPolicy, Integer restartRetries, UpdateEntities config) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = containerUpdateLibpodRequestBuilder(name, restartPolicy, restartRetries, config);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("containerUpdateLibpod", localVarResponse);
        }
        return new ApiResponse<Void>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
            // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder containerUpdateLibpodRequestBuilder(String name, String restartPolicy, Integer restartRetries, UpdateEntities config) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling containerUpdateLibpod");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/containers/{name}/update"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "restartPolicy";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("restartPolicy", restartPolicy));
    localVarQueryParameterBaseName = "restartRetries";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("restartRetries", restartRetries));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(config);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Wait on a container
   * Wait on a container to meet a given condition
   * @param name the name or ID of the container (required)
   * @param condition Conditions to wait for. If no condition provided the &#39;exited&#39; condition is assumed. (optional)
   * @param interval Time Interval to wait before polling for completion. (optional, default to 250ms)
   * @return Integer
   * @throws ApiException if fails to make API call
   */
  public Integer containerWaitLibpod(String name, List<String> condition, String interval) throws ApiException {
    ApiResponse<Integer> localVarResponse = containerWaitLibpodWithHttpInfo(name, condition, interval);
    return localVarResponse.getData();
  }

  /**
   * Wait on a container
   * Wait on a container to meet a given condition
   * @param name the name or ID of the container (required)
   * @param condition Conditions to wait for. If no condition provided the &#39;exited&#39; condition is assumed. (optional)
   * @param interval Time Interval to wait before polling for completion. (optional, default to 250ms)
   * @return ApiResponse&lt;Integer&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Integer> containerWaitLibpodWithHttpInfo(String name, List<String> condition, String interval) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = containerWaitLibpodRequestBuilder(name, condition, interval);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("containerWaitLibpod", localVarResponse);
        }
        return new ApiResponse<Integer>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<Integer>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder containerWaitLibpodRequestBuilder(String name, List<String> condition, String interval) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling containerWaitLibpod");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/containers/{name}/wait"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "condition";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "condition", condition));
    localVarQueryParameterBaseName = "interval";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("interval", interval));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json, text/plain");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Get stats for one or more containers
   * Return a live stream of resource usage statistics of one or more container. If no container is specified, the statistics of all containers are returned.
   * @param containers names or IDs of containers (optional)
   * @param stream Stream the output (optional, default to true)
   * @param interval Time in seconds between stats reports (optional, default to 5)
   * @return ContainerStats
   * @throws ApiException if fails to make API call
   */
  public ContainerStats containersStatsAllLibpod(List<String> containers, Boolean stream, Integer interval) throws ApiException {
    ApiResponse<ContainerStats> localVarResponse = containersStatsAllLibpodWithHttpInfo(containers, stream, interval);
    return localVarResponse.getData();
  }

  /**
   * Get stats for one or more containers
   * Return a live stream of resource usage statistics of one or more container. If no container is specified, the statistics of all containers are returned.
   * @param containers names or IDs of containers (optional)
   * @param stream Stream the output (optional, default to true)
   * @param interval Time in seconds between stats reports (optional, default to 5)
   * @return ApiResponse&lt;ContainerStats&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ContainerStats> containersStatsAllLibpodWithHttpInfo(List<String> containers, Boolean stream, Integer interval) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = containersStatsAllLibpodRequestBuilder(containers, stream, interval);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("containersStatsAllLibpod", localVarResponse);
        }
        return new ApiResponse<ContainerStats>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<ContainerStats>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder containersStatsAllLibpodRequestBuilder(List<String> containers, Boolean stream, Integer interval) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/containers/stats";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "containers";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "containers", containers));
    localVarQueryParameterBaseName = "stream";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("stream", stream));
    localVarQueryParameterBaseName = "interval";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("interval", interval));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Generate a Kubernetes YAML file.
   * Generate Kubernetes YAML based on a pod or container.
   * @param names Name or ID of the container or pod. (required)
   * @param service Generate YAML for a Kubernetes service object. (optional, default to false)
   * @param type Generate YAML for the given Kubernetes kind. (optional, default to pod)
   * @param replicas Set the replica number for Deployment kind. (optional, default to 0)
   * @param noTrunc don&#39;t truncate annotations to the Kubernetes maximum length of 63 characters (optional, default to false)
   * @param podmanOnly add podman-only reserved annotations in generated YAML file (cannot be used by Kubernetes) (optional, default to false)
   * @return File
   * @throws ApiException if fails to make API call
   */
  public File generateKubeLibpod(List<String> names, Boolean service, String type, Integer replicas, Boolean noTrunc, Boolean podmanOnly) throws ApiException {
    ApiResponse<File> localVarResponse = generateKubeLibpodWithHttpInfo(names, service, type, replicas, noTrunc, podmanOnly);
    return localVarResponse.getData();
  }

  /**
   * Generate a Kubernetes YAML file.
   * Generate Kubernetes YAML based on a pod or container.
   * @param names Name or ID of the container or pod. (required)
   * @param service Generate YAML for a Kubernetes service object. (optional, default to false)
   * @param type Generate YAML for the given Kubernetes kind. (optional, default to pod)
   * @param replicas Set the replica number for Deployment kind. (optional, default to 0)
   * @param noTrunc don&#39;t truncate annotations to the Kubernetes maximum length of 63 characters (optional, default to false)
   * @param podmanOnly add podman-only reserved annotations in generated YAML file (cannot be used by Kubernetes) (optional, default to false)
   * @return ApiResponse&lt;File&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<File> generateKubeLibpodWithHttpInfo(List<String> names, Boolean service, String type, Integer replicas, Boolean noTrunc, Boolean podmanOnly) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = generateKubeLibpodRequestBuilder(names, service, type, replicas, noTrunc, podmanOnly);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("generateKubeLibpod", localVarResponse);
        }
        return new ApiResponse<File>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<File>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder generateKubeLibpodRequestBuilder(List<String> names, Boolean service, String type, Integer replicas, Boolean noTrunc, Boolean podmanOnly) throws ApiException {
    // verify the required parameter 'names' is set
    if (names == null) {
      throw new ApiException(400, "Missing the required parameter 'names' when calling generateKubeLibpod");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/generate/kube";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "names";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "names", names));
    localVarQueryParameterBaseName = "service";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("service", service));
    localVarQueryParameterBaseName = "type";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("type", type));
    localVarQueryParameterBaseName = "replicas";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("replicas", replicas));
    localVarQueryParameterBaseName = "noTrunc";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("noTrunc", noTrunc));
    localVarQueryParameterBaseName = "podmanOnly";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("podmanOnly", podmanOnly));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "text/vnd.yaml, application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Generate Systemd Units
   * Generate Systemd Units based on a pod or container.
   * @param name Name or ID of the container or pod. (required)
   * @param useName Use container/pod names instead of IDs. (optional, default to false)
   * @param _new Create a new container instead of starting an existing one. (optional, default to false)
   * @param noHeader Do not generate the header including the Podman version and the timestamp. (optional, default to false)
   * @param startTimeout Start timeout in seconds. (optional, default to 0)
   * @param stopTimeout Stop timeout in seconds. (optional, default to 10)
   * @param restartPolicy Systemd restart-policy. (optional, default to on-failure)
   * @param containerPrefix Systemd unit name prefix for containers. (optional, default to container)
   * @param podPrefix Systemd unit name prefix for pods. (optional, default to pod)
   * @param separator Systemd unit name separator between name/id and prefix. (optional, default to -)
   * @param restartSec Configures the time to sleep before restarting a service. (optional, default to 0)
   * @param wants Systemd Wants list for the container or pods. (optional)
   * @param after Systemd After list for the container or pods. (optional)
   * @param requires Systemd Requires list for the container or pods. (optional)
   * @param additionalEnvVariables Set environment variables to the systemd unit files. (optional)
   * @return Map&lt;String, String&gt;
   * @throws ApiException if fails to make API call
   */
  public Map<String, String> generateSystemdLibpod(String name, Boolean useName, Boolean _new, Boolean noHeader, Integer startTimeout, Integer stopTimeout, String restartPolicy, String containerPrefix, String podPrefix, String separator, Integer restartSec, List<String> wants, List<String> after, List<String> requires, List<String> additionalEnvVariables) throws ApiException {
    ApiResponse<Map<String, String>> localVarResponse = generateSystemdLibpodWithHttpInfo(name, useName, _new, noHeader, startTimeout, stopTimeout, restartPolicy, containerPrefix, podPrefix, separator, restartSec, wants, after, requires, additionalEnvVariables);
    return localVarResponse.getData();
  }

  /**
   * Generate Systemd Units
   * Generate Systemd Units based on a pod or container.
   * @param name Name or ID of the container or pod. (required)
   * @param useName Use container/pod names instead of IDs. (optional, default to false)
   * @param _new Create a new container instead of starting an existing one. (optional, default to false)
   * @param noHeader Do not generate the header including the Podman version and the timestamp. (optional, default to false)
   * @param startTimeout Start timeout in seconds. (optional, default to 0)
   * @param stopTimeout Stop timeout in seconds. (optional, default to 10)
   * @param restartPolicy Systemd restart-policy. (optional, default to on-failure)
   * @param containerPrefix Systemd unit name prefix for containers. (optional, default to container)
   * @param podPrefix Systemd unit name prefix for pods. (optional, default to pod)
   * @param separator Systemd unit name separator between name/id and prefix. (optional, default to -)
   * @param restartSec Configures the time to sleep before restarting a service. (optional, default to 0)
   * @param wants Systemd Wants list for the container or pods. (optional)
   * @param after Systemd After list for the container or pods. (optional)
   * @param requires Systemd Requires list for the container or pods. (optional)
   * @param additionalEnvVariables Set environment variables to the systemd unit files. (optional)
   * @return ApiResponse&lt;Map&lt;String, String&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Map<String, String>> generateSystemdLibpodWithHttpInfo(String name, Boolean useName, Boolean _new, Boolean noHeader, Integer startTimeout, Integer stopTimeout, String restartPolicy, String containerPrefix, String podPrefix, String separator, Integer restartSec, List<String> wants, List<String> after, List<String> requires, List<String> additionalEnvVariables) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = generateSystemdLibpodRequestBuilder(name, useName, _new, noHeader, startTimeout, stopTimeout, restartPolicy, containerPrefix, podPrefix, separator, restartSec, wants, after, requires, additionalEnvVariables);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("generateSystemdLibpod", localVarResponse);
        }
        return new ApiResponse<Map<String, String>>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<Map<String, String>>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder generateSystemdLibpodRequestBuilder(String name, Boolean useName, Boolean _new, Boolean noHeader, Integer startTimeout, Integer stopTimeout, String restartPolicy, String containerPrefix, String podPrefix, String separator, Integer restartSec, List<String> wants, List<String> after, List<String> requires, List<String> additionalEnvVariables) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling generateSystemdLibpod");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/generate/{name}/systemd"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "useName";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("useName", useName));
    localVarQueryParameterBaseName = "new";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("new", _new));
    localVarQueryParameterBaseName = "noHeader";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("noHeader", noHeader));
    localVarQueryParameterBaseName = "startTimeout";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("startTimeout", startTimeout));
    localVarQueryParameterBaseName = "stopTimeout";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("stopTimeout", stopTimeout));
    localVarQueryParameterBaseName = "restartPolicy";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("restartPolicy", restartPolicy));
    localVarQueryParameterBaseName = "containerPrefix";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("containerPrefix", containerPrefix));
    localVarQueryParameterBaseName = "podPrefix";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("podPrefix", podPrefix));
    localVarQueryParameterBaseName = "separator";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("separator", separator));
    localVarQueryParameterBaseName = "restartSec";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("restartSec", restartSec));
    localVarQueryParameterBaseName = "wants";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "wants", wants));
    localVarQueryParameterBaseName = "after";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "after", after));
    localVarQueryParameterBaseName = "requires";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "requires", requires));
    localVarQueryParameterBaseName = "additionalEnvVariables";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "additionalEnvVariables", additionalEnvVariables));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Commit
   * Create a new image from a container
   * @param container the name or ID of a container (required)
   * @param author author of the image (optional)
   * @param changes instructions to apply while committing in Dockerfile format (i.e. \&quot;CMD&#x3D;/bin/foo\&quot;) (optional)
   * @param comment commit message (optional)
   * @param format format of the image manifest and metadata (default \&quot;oci\&quot;) (optional)
   * @param pause pause the container before committing it (optional)
   * @param squash squash the container before committing it (optional)
   * @param repo the repository name for the created image (optional)
   * @param stream output from commit process (optional)
   * @param tag tag name for the created image (optional)
   * @throws ApiException if fails to make API call
   */
  public void imageCommitLibpod(String container, String author, List<String> changes, String comment, String format, Boolean pause, Boolean squash, String repo, Boolean stream, String tag) throws ApiException {
    imageCommitLibpodWithHttpInfo(container, author, changes, comment, format, pause, squash, repo, stream, tag);
  }

  /**
   * Commit
   * Create a new image from a container
   * @param container the name or ID of a container (required)
   * @param author author of the image (optional)
   * @param changes instructions to apply while committing in Dockerfile format (i.e. \&quot;CMD&#x3D;/bin/foo\&quot;) (optional)
   * @param comment commit message (optional)
   * @param format format of the image manifest and metadata (default \&quot;oci\&quot;) (optional)
   * @param pause pause the container before committing it (optional)
   * @param squash squash the container before committing it (optional)
   * @param repo the repository name for the created image (optional)
   * @param stream output from commit process (optional)
   * @param tag tag name for the created image (optional)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> imageCommitLibpodWithHttpInfo(String container, String author, List<String> changes, String comment, String format, Boolean pause, Boolean squash, String repo, Boolean stream, String tag) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = imageCommitLibpodRequestBuilder(container, author, changes, comment, format, pause, squash, repo, stream, tag);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("imageCommitLibpod", localVarResponse);
        }
        return new ApiResponse<Void>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
            // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder imageCommitLibpodRequestBuilder(String container, String author, List<String> changes, String comment, String format, Boolean pause, Boolean squash, String repo, Boolean stream, String tag) throws ApiException {
    // verify the required parameter 'container' is set
    if (container == null) {
      throw new ApiException(400, "Missing the required parameter 'container' when calling imageCommitLibpod");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/commit";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "container";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("container", container));
    localVarQueryParameterBaseName = "author";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("author", author));
    localVarQueryParameterBaseName = "changes";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "changes", changes));
    localVarQueryParameterBaseName = "comment";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("comment", comment));
    localVarQueryParameterBaseName = "format";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("format", format));
    localVarQueryParameterBaseName = "pause";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("pause", pause));
    localVarQueryParameterBaseName = "squash";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("squash", squash));
    localVarQueryParameterBaseName = "repo";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("repo", repo));
    localVarQueryParameterBaseName = "stream";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("stream", stream));
    localVarQueryParameterBaseName = "tag";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("tag", tag));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Apply a podman workload or Kubernetes YAML file.
   * Deploy a podman container, pod, volume, or Kubernetes yaml to a Kubernetes cluster.
   * @param caCertFile Path to the CA cert file for the Kubernetes cluster. (optional)
   * @param kubeConfig Path to the kubeconfig file for the Kubernetes cluster. (optional)
   * @param namespace The namespace to deploy the workload to on the Kubernetes cluster. (optional)
   * @param service Create a service object for the container being deployed. (optional)
   * @param _file Path to the Kubernetes yaml file to deploy. (optional)
   * @param request Kubernetes YAML file. (optional)
   * @return File
   * @throws ApiException if fails to make API call
   */
  public File kubeApplyLibpod(String caCertFile, String kubeConfig, String namespace, Boolean service, String _file, String request) throws ApiException {
    ApiResponse<File> localVarResponse = kubeApplyLibpodWithHttpInfo(caCertFile, kubeConfig, namespace, service, _file, request);
    return localVarResponse.getData();
  }

  /**
   * Apply a podman workload or Kubernetes YAML file.
   * Deploy a podman container, pod, volume, or Kubernetes yaml to a Kubernetes cluster.
   * @param caCertFile Path to the CA cert file for the Kubernetes cluster. (optional)
   * @param kubeConfig Path to the kubeconfig file for the Kubernetes cluster. (optional)
   * @param namespace The namespace to deploy the workload to on the Kubernetes cluster. (optional)
   * @param service Create a service object for the container being deployed. (optional)
   * @param _file Path to the Kubernetes yaml file to deploy. (optional)
   * @param request Kubernetes YAML file. (optional)
   * @return ApiResponse&lt;File&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<File> kubeApplyLibpodWithHttpInfo(String caCertFile, String kubeConfig, String namespace, Boolean service, String _file, String request) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = kubeApplyLibpodRequestBuilder(caCertFile, kubeConfig, namespace, service, _file, request);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("kubeApplyLibpod", localVarResponse);
        }
        return new ApiResponse<File>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<File>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder kubeApplyLibpodRequestBuilder(String caCertFile, String kubeConfig, String namespace, Boolean service, String _file, String request) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/kube/apply";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "caCertFile";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("caCertFile", caCertFile));
    localVarQueryParameterBaseName = "kubeConfig";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("kubeConfig", kubeConfig));
    localVarQueryParameterBaseName = "namespace";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("namespace", namespace));
    localVarQueryParameterBaseName = "service";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("service", service));
    localVarQueryParameterBaseName = "file";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("file", _file));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofString(request));
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Remove resources created from kube play
   * Tears down pods, secrets, and volumes defined in a YAML file
   * @param contentType  (optional, default to plain/text)
   * @param force Remove volumes. (optional, default to false)
   * @param request Kubernetes YAML file. (optional)
   * @return PlayKubeReport
   * @throws ApiException if fails to make API call
   */
  public PlayKubeReport playKubeDownLibpod(String contentType, Boolean force, String request) throws ApiException {
    ApiResponse<PlayKubeReport> localVarResponse = playKubeDownLibpodWithHttpInfo(contentType, force, request);
    return localVarResponse.getData();
  }

  /**
   * Remove resources created from kube play
   * Tears down pods, secrets, and volumes defined in a YAML file
   * @param contentType  (optional, default to plain/text)
   * @param force Remove volumes. (optional, default to false)
   * @param request Kubernetes YAML file. (optional)
   * @return ApiResponse&lt;PlayKubeReport&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<PlayKubeReport> playKubeDownLibpodWithHttpInfo(String contentType, Boolean force, String request) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = playKubeDownLibpodRequestBuilder(contentType, force, request);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("playKubeDownLibpod", localVarResponse);
        }
        return new ApiResponse<PlayKubeReport>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<PlayKubeReport>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder playKubeDownLibpodRequestBuilder(String contentType, Boolean force, String request) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/play/kube";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "force";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("force", force));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    if (contentType != null) {
      localVarRequestBuilder.header("Content-Type", contentType.toString());
    }
    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("DELETE", HttpRequest.BodyPublishers.ofString(request));
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Play a Kubernetes YAML file.
   * Create and run pods based on a Kubernetes YAML file.  ### Content-Type  Then endpoint support two Content-Type  - &#x60;plain/text&#x60; for yaml format  - &#x60;application/x-tar&#x60; for sending context(s) required for building images  #### Tar format  The tar format must contain a &#x60;play.yaml&#x60; file at the root that will be used. If the file format requires context to build an image, it uses the image name and check for corresponding folder.  For example, the client sends a tar file with the following structure:  &#x60;&#x60;&#x60; â””â”€â”€ content.tar  â”œâ”€â”€ play.yaml  â””â”€â”€ foobar/      â””â”€â”€ Containerfile &#x60;&#x60;&#x60;  The &#x60;play.yaml&#x60; is the following, the &#x60;foobar&#x60; image means we are looking for a context with this name. &#x60;&#x60;&#x60; apiVersion: v1 kind: Pod metadata: name: demo-build-remote spec: containers:  - name: container    image: foobar &#x60;&#x60;&#x60; 
   * @param contentType  (optional, default to plain/text)
   * @param annotations JSON encoded value of annotations (a map[string]string). (optional)
   * @param logDriver Logging driver for the containers in the pod. (optional)
   * @param logOptions logging driver options (optional)
   * @param network USe the network mode or specify an array of networks. (optional)
   * @param noHosts do not setup /etc/hosts file in container (optional, default to false)
   * @param noTrunc use annotations that are not truncated to the Kubernetes maximum length of 63 characters (optional, default to false)
   * @param publishPorts publish a container&#39;s port, or a range of ports, to the host (optional)
   * @param publishAllPorts Whether to publish all ports defined in the K8S YAML file (containerPort, hostPort), if false only hostPort will be published (optional)
   * @param replace replace existing pods and containers (optional, default to false)
   * @param serviceContainer Starts a service container before all pods. (optional, default to false)
   * @param start Start the pod after creating it. (optional, default to true)
   * @param staticIPs Static IPs used for the pods. (optional)
   * @param staticMACs Static MACs used for the pods. (optional)
   * @param tlsVerify Require HTTPS and verify signatures when contacting registries. (optional, default to true)
   * @param userns Set the user namespace mode for the pods. (optional)
   * @param wait Clean up all objects created when a SIGTERM is received or pods exit. (optional, default to false)
   * @param build Build the images with corresponding context. (optional)
   * @param request Kubernetes YAML file. (optional)
   * @return PlayKubeReport
   * @throws ApiException if fails to make API call
   */
  public PlayKubeReport playKubeLibpod(String contentType, String annotations, String logDriver, List<String> logOptions, List<String> network, Boolean noHosts, Boolean noTrunc, List<String> publishPorts, Boolean publishAllPorts, Boolean replace, Boolean serviceContainer, Boolean start, List<String> staticIPs, List<String> staticMACs, Boolean tlsVerify, String userns, Boolean wait, Boolean build, String request) throws ApiException {
    ApiResponse<PlayKubeReport> localVarResponse = playKubeLibpodWithHttpInfo(contentType, annotations, logDriver, logOptions, network, noHosts, noTrunc, publishPorts, publishAllPorts, replace, serviceContainer, start, staticIPs, staticMACs, tlsVerify, userns, wait, build, request);
    return localVarResponse.getData();
  }

  /**
   * Play a Kubernetes YAML file.
   * Create and run pods based on a Kubernetes YAML file.  ### Content-Type  Then endpoint support two Content-Type  - &#x60;plain/text&#x60; for yaml format  - &#x60;application/x-tar&#x60; for sending context(s) required for building images  #### Tar format  The tar format must contain a &#x60;play.yaml&#x60; file at the root that will be used. If the file format requires context to build an image, it uses the image name and check for corresponding folder.  For example, the client sends a tar file with the following structure:  &#x60;&#x60;&#x60; â””â”€â”€ content.tar  â”œâ”€â”€ play.yaml  â””â”€â”€ foobar/      â””â”€â”€ Containerfile &#x60;&#x60;&#x60;  The &#x60;play.yaml&#x60; is the following, the &#x60;foobar&#x60; image means we are looking for a context with this name. &#x60;&#x60;&#x60; apiVersion: v1 kind: Pod metadata: name: demo-build-remote spec: containers:  - name: container    image: foobar &#x60;&#x60;&#x60; 
   * @param contentType  (optional, default to plain/text)
   * @param annotations JSON encoded value of annotations (a map[string]string). (optional)
   * @param logDriver Logging driver for the containers in the pod. (optional)
   * @param logOptions logging driver options (optional)
   * @param network USe the network mode or specify an array of networks. (optional)
   * @param noHosts do not setup /etc/hosts file in container (optional, default to false)
   * @param noTrunc use annotations that are not truncated to the Kubernetes maximum length of 63 characters (optional, default to false)
   * @param publishPorts publish a container&#39;s port, or a range of ports, to the host (optional)
   * @param publishAllPorts Whether to publish all ports defined in the K8S YAML file (containerPort, hostPort), if false only hostPort will be published (optional)
   * @param replace replace existing pods and containers (optional, default to false)
   * @param serviceContainer Starts a service container before all pods. (optional, default to false)
   * @param start Start the pod after creating it. (optional, default to true)
   * @param staticIPs Static IPs used for the pods. (optional)
   * @param staticMACs Static MACs used for the pods. (optional)
   * @param tlsVerify Require HTTPS and verify signatures when contacting registries. (optional, default to true)
   * @param userns Set the user namespace mode for the pods. (optional)
   * @param wait Clean up all objects created when a SIGTERM is received or pods exit. (optional, default to false)
   * @param build Build the images with corresponding context. (optional)
   * @param request Kubernetes YAML file. (optional)
   * @return ApiResponse&lt;PlayKubeReport&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<PlayKubeReport> playKubeLibpodWithHttpInfo(String contentType, String annotations, String logDriver, List<String> logOptions, List<String> network, Boolean noHosts, Boolean noTrunc, List<String> publishPorts, Boolean publishAllPorts, Boolean replace, Boolean serviceContainer, Boolean start, List<String> staticIPs, List<String> staticMACs, Boolean tlsVerify, String userns, Boolean wait, Boolean build, String request) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = playKubeLibpodRequestBuilder(contentType, annotations, logDriver, logOptions, network, noHosts, noTrunc, publishPorts, publishAllPorts, replace, serviceContainer, start, staticIPs, staticMACs, tlsVerify, userns, wait, build, request);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("playKubeLibpod", localVarResponse);
        }
        return new ApiResponse<PlayKubeReport>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<PlayKubeReport>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder playKubeLibpodRequestBuilder(String contentType, String annotations, String logDriver, List<String> logOptions, List<String> network, Boolean noHosts, Boolean noTrunc, List<String> publishPorts, Boolean publishAllPorts, Boolean replace, Boolean serviceContainer, Boolean start, List<String> staticIPs, List<String> staticMACs, Boolean tlsVerify, String userns, Boolean wait, Boolean build, String request) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/play/kube";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "annotations";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("annotations", annotations));
    localVarQueryParameterBaseName = "logDriver";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("logDriver", logDriver));
    localVarQueryParameterBaseName = "logOptions";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "logOptions", logOptions));
    localVarQueryParameterBaseName = "network";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "network", network));
    localVarQueryParameterBaseName = "noHosts";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("noHosts", noHosts));
    localVarQueryParameterBaseName = "noTrunc";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("noTrunc", noTrunc));
    localVarQueryParameterBaseName = "publishPorts";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "publishPorts", publishPorts));
    localVarQueryParameterBaseName = "publishAllPorts";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("publishAllPorts", publishAllPorts));
    localVarQueryParameterBaseName = "replace";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("replace", replace));
    localVarQueryParameterBaseName = "serviceContainer";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("serviceContainer", serviceContainer));
    localVarQueryParameterBaseName = "start";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("start", start));
    localVarQueryParameterBaseName = "staticIPs";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "staticIPs", staticIPs));
    localVarQueryParameterBaseName = "staticMACs";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "staticMACs", staticMACs));
    localVarQueryParameterBaseName = "tlsVerify";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("tlsVerify", tlsVerify));
    localVarQueryParameterBaseName = "userns";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("userns", userns));
    localVarQueryParameterBaseName = "wait";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("wait", wait));
    localVarQueryParameterBaseName = "build";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("build", build));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    if (contentType != null) {
      localVarRequestBuilder.header("Content-Type", contentType.toString());
    }
    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofString(request));
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Copy files into a container
   * Copy a tar archive of files into a container
   * @param name container name or id (required)
   * @param path Path to a directory in the container to extract (required)
   * @param pause pause the container while copying (defaults to true) (optional, default to true)
   * @param request tarfile of files to copy into the container (optional)
   * @throws ApiException if fails to make API call
   */
  public void putContainerArchiveLibpod(String name, String path, Boolean pause, String request) throws ApiException {
    putContainerArchiveLibpodWithHttpInfo(name, path, pause, request);
  }

  /**
   * Copy files into a container
   * Copy a tar archive of files into a container
   * @param name container name or id (required)
   * @param path Path to a directory in the container to extract (required)
   * @param pause pause the container while copying (defaults to true) (optional, default to true)
   * @param request tarfile of files to copy into the container (optional)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> putContainerArchiveLibpodWithHttpInfo(String name, String path, Boolean pause, String request) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = putContainerArchiveLibpodRequestBuilder(name, path, pause, request);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("putContainerArchiveLibpod", localVarResponse);
        }
        return new ApiResponse<Void>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
            // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder putContainerArchiveLibpodRequestBuilder(String name, String path, Boolean pause, String request) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling putContainerArchiveLibpod");
    }
    // verify the required parameter 'path' is set
    if (path == null) {
      throw new ApiException(400, "Missing the required parameter 'path' when calling putContainerArchiveLibpod");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/libpod/containers/{name}/archive"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "path";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("path", path));
    localVarQueryParameterBaseName = "pause";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("pause", pause));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("PUT", HttpRequest.BodyPublishers.ofString(request));
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

}
