/*
 * supports a RESTful API for the Libpod library
 * This documentation describes the Podman v2.x+ RESTful API. It consists of a Docker-compatible API and a Libpod API providing support for Podman’s unique features such as pods.  To start the service and keep it running for 5,000 seconds (-t 0 runs forever):  podman system service -t 5000 &  You can then use cURL on the socket using requests documented below.  NOTE: if you install the package podman-docker, it will create a symbolic link for /run/docker.sock to /run/podman/podman.sock  NOTE: Some fields in the API response JSON are encoded as omitempty, which means that if said field has a zero value, they will not be encoded in the API response. This is a feature to help reduce the size of the JSON responses returned via the API.  NOTE: Due to the limitations of [go-swagger](https://github.com/go-swagger/go-swagger), some field values that have a complex type show up as null in the docs as well as in the API responses. This is because the zero value for the field type is null. The field description in the docs will state what type the field is expected to be for such cases.  See podman-system-service(1) for more information.  Quick Examples:  'podman info'  curl --unix-socket /run/podman/podman.sock http://d/v5.0.0/libpod/info  'podman pull quay.io/containers/podman'  curl -XPOST --unix-socket /run/podman/podman.sock -v 'http://d/v5.0.0/images/create?fromImage=quay.io%2Fcontainers%2Fpodman'  'podman list images'  curl --unix-socket /run/podman/podman.sock -v 'http://d/v5.0.0/libpod/images/json' | jq
 *
 * The version of the OpenAPI document: 5.0.0
 * Contact: podman@lists.podman.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package io.github.alersrt.pod4j.openapi.api;

import io.github.alersrt.pod4j.openapi.ApiClient;
import io.github.alersrt.pod4j.openapi.ApiException;
import io.github.alersrt.pod4j.openapi.ApiResponse;
import io.github.alersrt.pod4j.openapi.Pair;

import io.github.alersrt.pod4j.openapi.model.ErrorModel;
import java.io.File;
import io.github.alersrt.pod4j.openapi.model.HistoryResponse;
import io.github.alersrt.pod4j.openapi.model.ImageBuild200Response;
import io.github.alersrt.pod4j.openapi.model.ImageDelete200ResponseInner;
import io.github.alersrt.pod4j.openapi.model.ImageInspect;
import io.github.alersrt.pod4j.openapi.model.ImageSearch200Response;
import io.github.alersrt.pod4j.openapi.model.Summary;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import jakarta.validation.constraints.*;
import jakarta.validation.Valid;

import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.net.http.HttpRequest;
import java.nio.channels.Channels;
import java.nio.channels.Pipe;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;

import java.util.ArrayList;
import java.util.StringJoiner;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-11-28T19:32:38.690938181+07:00[Asia/Barnaul]", comments = "Generator version: 7.7.0")
public class ImagesCompatApi {
  private final HttpClient memberVarHttpClient;
  private final ObjectMapper memberVarObjectMapper;
  private final String memberVarBaseUri;
  private final Consumer<HttpRequest.Builder> memberVarInterceptor;
  private final Duration memberVarReadTimeout;
  private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;
  private final Consumer<HttpResponse<String>> memberVarAsyncResponseInterceptor;

  public ImagesCompatApi() {
    this(new ApiClient());
  }

  public ImagesCompatApi(ApiClient apiClient) {
    memberVarHttpClient = apiClient.getHttpClient();
    memberVarObjectMapper = apiClient.getObjectMapper();
    memberVarBaseUri = apiClient.getBaseUri();
    memberVarInterceptor = apiClient.getRequestInterceptor();
    memberVarReadTimeout = apiClient.getReadTimeout();
    memberVarResponseInterceptor = apiClient.getResponseInterceptor();
    memberVarAsyncResponseInterceptor = apiClient.getAsyncResponseInterceptor();
  }

  protected ApiException getApiException(String operationId, HttpResponse<InputStream> response) throws IOException {
    String body = response.body() == null ? null : new String(response.body().readAllBytes());
    String message = formatExceptionMessage(operationId, response.statusCode(), body);
    return new ApiException(response.statusCode(), message, response.headers(), body);
  }

  private String formatExceptionMessage(String operationId, int statusCode, String body) {
    if (body == null || body.isEmpty()) {
      body = "[no body]";
    }
    return operationId + " call failed with: " + statusCode + " - " + body;
  }

  /**
   * Create image
   * Build an image from the given Dockerfile(s)
   * @param contentType  (optional, default to application/x-tar)
   * @param xRegistryConfig  (optional)
   * @param dockerfile Path within the build context to the &#x60;Dockerfile&#x60;. This is ignored if remote is specified and points to an external &#x60;Dockerfile&#x60;.  (optional, default to Dockerfile)
   * @param t A name and optional tag to apply to the image in the &#x60;name:tag&#x60; format. If you omit the tag, the default latest value is assumed. You can provide several t parameters. (optional, default to latest)
   * @param extrahosts TBD Extra hosts to add to /etc/hosts (As of version 1.xx)  (optional)
   * @param remote A Git repository URI or HTTP/HTTPS context URI. If the URI points to a single text file, the file’s contents are placed into a file called Dockerfile and the image is built from that file. If the URI points to a tarball, the file is downloaded by the daemon and the contents therein used as the context for the build. If the URI points to a tarball and the dockerfile parameter is also specified, there must be a file with the corresponding path inside the tarball. (As of version 1.xx)  (optional)
   * @param retry Number of times to retry in case of failure when performing push/pull.  (optional, default to 3)
   * @param retryDelay Delay between retries in case of push/pull failures.  (optional, default to 2s)
   * @param q Suppress verbose build output  (optional, default to false)
   * @param compatvolumes Contents of base images to be modified on ADD or COPY only (As of Podman version v5.2)  (optional, default to false)
   * @param nocache Do not use the cache when building the image (As of version 1.xx)  (optional, default to false)
   * @param cachefrom JSON array of images used to build cache resolution (As of version 1.xx)  (optional)
   * @param pull Attempt to pull the image even if an older image exists locally (As of version 1.xx)  (optional, default to false)
   * @param rm Remove intermediate containers after a successful build (As of version 1.xx)  (optional, default to true)
   * @param forcerm Always remove intermediate containers, even upon failure (As of version 1.xx)  (optional, default to false)
   * @param memory Memory is the upper limit (in bytes) on how much memory running containers can use (As of version 1.xx)  (optional)
   * @param memswap MemorySwap limits the amount of memory and swap together (As of version 1.xx)  (optional)
   * @param cpushares CPUShares (relative weight (As of version 1.xx)  (optional)
   * @param cpusetcpus CPUSetCPUs in which to allow execution (0-3, 0,1) (As of version 1.xx)  (optional)
   * @param cpuperiod CPUPeriod limits the CPU CFS (Completely Fair Scheduler) period (As of version 1.xx)  (optional)
   * @param cpuquota CPUQuota limits the CPU CFS (Completely Fair Scheduler) quota (As of version 1.xx)  (optional)
   * @param buildargs JSON map of string pairs denoting build-time variables. For example, the build argument &#x60;Foo&#x60; with the value of &#x60;bar&#x60; would be encoded in JSON as &#x60;[\&quot;Foo\&quot;:\&quot;bar\&quot;]&#x60;.  For example, buildargs&#x3D;{\&quot;Foo\&quot;:\&quot;bar\&quot;}.  Note(s): * This should not be used to pass secrets. * The value of buildargs should be URI component encoded before being passed to the API.  (As of version 1.xx)  (optional)
   * @param shmsize ShmSize is the \&quot;size\&quot; value to use when mounting an shmfs on the container&#39;s /dev/shm directory. Default is 64MB (As of version 1.xx)  (optional, default to 67108864)
   * @param squash Silently ignored. Squash the resulting images layers into a single layer (As of version 1.xx)  (optional, default to false)
   * @param labels JSON map of key, value pairs to set as labels on the new image (As of version 1.xx)  (optional)
   * @param networkmode Sets the networking mode for the run commands during build. Supported standard values are:   * &#x60;bridge&#x60; limited to containers within a single host, port mapping required for external access   * &#x60;host&#x60; no isolation between host and containers on this network   * &#x60;none&#x60; disable all networking for this container   * container:&lt;nameOrID&gt; share networking with given container   ---All other values are assumed to be a custom network&#39;s name (As of version 1.xx)  (optional, default to bridge)
   * @param platform Platform format os[/arch[/variant]] Can be comma separated list for multi arch builds. (As of version 1.xx)  (optional)
   * @param target Target build stage (As of version 1.xx)  (optional)
   * @param outputs output configuration TBD (As of version 1.xx)  (optional)
   * @param inputStream A tar archive compressed with one of the following algorithms: identity (no compression), gzip, bzip2, xz.  (optional)
   * @return ImageBuild200Response
   * @throws ApiException if fails to make API call
   */
  public ImageBuild200Response imageBuild(String contentType, String xRegistryConfig, String dockerfile, String t, String extrahosts, String remote, Integer retry, String retryDelay, Boolean q, Boolean compatvolumes, Boolean nocache, String cachefrom, Boolean pull, Boolean rm, Boolean forcerm, Integer memory, Integer memswap, Integer cpushares, String cpusetcpus, Integer cpuperiod, Integer cpuquota, String buildargs, Integer shmsize, Boolean squash, String labels, String networkmode, String platform, String target, String outputs, File inputStream) throws ApiException {
    ApiResponse<ImageBuild200Response> localVarResponse = imageBuildWithHttpInfo(contentType, xRegistryConfig, dockerfile, t, extrahosts, remote, retry, retryDelay, q, compatvolumes, nocache, cachefrom, pull, rm, forcerm, memory, memswap, cpushares, cpusetcpus, cpuperiod, cpuquota, buildargs, shmsize, squash, labels, networkmode, platform, target, outputs, inputStream);
    return localVarResponse.getData();
  }

  /**
   * Create image
   * Build an image from the given Dockerfile(s)
   * @param contentType  (optional, default to application/x-tar)
   * @param xRegistryConfig  (optional)
   * @param dockerfile Path within the build context to the &#x60;Dockerfile&#x60;. This is ignored if remote is specified and points to an external &#x60;Dockerfile&#x60;.  (optional, default to Dockerfile)
   * @param t A name and optional tag to apply to the image in the &#x60;name:tag&#x60; format. If you omit the tag, the default latest value is assumed. You can provide several t parameters. (optional, default to latest)
   * @param extrahosts TBD Extra hosts to add to /etc/hosts (As of version 1.xx)  (optional)
   * @param remote A Git repository URI or HTTP/HTTPS context URI. If the URI points to a single text file, the file’s contents are placed into a file called Dockerfile and the image is built from that file. If the URI points to a tarball, the file is downloaded by the daemon and the contents therein used as the context for the build. If the URI points to a tarball and the dockerfile parameter is also specified, there must be a file with the corresponding path inside the tarball. (As of version 1.xx)  (optional)
   * @param retry Number of times to retry in case of failure when performing push/pull.  (optional, default to 3)
   * @param retryDelay Delay between retries in case of push/pull failures.  (optional, default to 2s)
   * @param q Suppress verbose build output  (optional, default to false)
   * @param compatvolumes Contents of base images to be modified on ADD or COPY only (As of Podman version v5.2)  (optional, default to false)
   * @param nocache Do not use the cache when building the image (As of version 1.xx)  (optional, default to false)
   * @param cachefrom JSON array of images used to build cache resolution (As of version 1.xx)  (optional)
   * @param pull Attempt to pull the image even if an older image exists locally (As of version 1.xx)  (optional, default to false)
   * @param rm Remove intermediate containers after a successful build (As of version 1.xx)  (optional, default to true)
   * @param forcerm Always remove intermediate containers, even upon failure (As of version 1.xx)  (optional, default to false)
   * @param memory Memory is the upper limit (in bytes) on how much memory running containers can use (As of version 1.xx)  (optional)
   * @param memswap MemorySwap limits the amount of memory and swap together (As of version 1.xx)  (optional)
   * @param cpushares CPUShares (relative weight (As of version 1.xx)  (optional)
   * @param cpusetcpus CPUSetCPUs in which to allow execution (0-3, 0,1) (As of version 1.xx)  (optional)
   * @param cpuperiod CPUPeriod limits the CPU CFS (Completely Fair Scheduler) period (As of version 1.xx)  (optional)
   * @param cpuquota CPUQuota limits the CPU CFS (Completely Fair Scheduler) quota (As of version 1.xx)  (optional)
   * @param buildargs JSON map of string pairs denoting build-time variables. For example, the build argument &#x60;Foo&#x60; with the value of &#x60;bar&#x60; would be encoded in JSON as &#x60;[\&quot;Foo\&quot;:\&quot;bar\&quot;]&#x60;.  For example, buildargs&#x3D;{\&quot;Foo\&quot;:\&quot;bar\&quot;}.  Note(s): * This should not be used to pass secrets. * The value of buildargs should be URI component encoded before being passed to the API.  (As of version 1.xx)  (optional)
   * @param shmsize ShmSize is the \&quot;size\&quot; value to use when mounting an shmfs on the container&#39;s /dev/shm directory. Default is 64MB (As of version 1.xx)  (optional, default to 67108864)
   * @param squash Silently ignored. Squash the resulting images layers into a single layer (As of version 1.xx)  (optional, default to false)
   * @param labels JSON map of key, value pairs to set as labels on the new image (As of version 1.xx)  (optional)
   * @param networkmode Sets the networking mode for the run commands during build. Supported standard values are:   * &#x60;bridge&#x60; limited to containers within a single host, port mapping required for external access   * &#x60;host&#x60; no isolation between host and containers on this network   * &#x60;none&#x60; disable all networking for this container   * container:&lt;nameOrID&gt; share networking with given container   ---All other values are assumed to be a custom network&#39;s name (As of version 1.xx)  (optional, default to bridge)
   * @param platform Platform format os[/arch[/variant]] Can be comma separated list for multi arch builds. (As of version 1.xx)  (optional)
   * @param target Target build stage (As of version 1.xx)  (optional)
   * @param outputs output configuration TBD (As of version 1.xx)  (optional)
   * @param inputStream A tar archive compressed with one of the following algorithms: identity (no compression), gzip, bzip2, xz.  (optional)
   * @return ApiResponse&lt;ImageBuild200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ImageBuild200Response> imageBuildWithHttpInfo(String contentType, String xRegistryConfig, String dockerfile, String t, String extrahosts, String remote, Integer retry, String retryDelay, Boolean q, Boolean compatvolumes, Boolean nocache, String cachefrom, Boolean pull, Boolean rm, Boolean forcerm, Integer memory, Integer memswap, Integer cpushares, String cpusetcpus, Integer cpuperiod, Integer cpuquota, String buildargs, Integer shmsize, Boolean squash, String labels, String networkmode, String platform, String target, String outputs, File inputStream) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = imageBuildRequestBuilder(contentType, xRegistryConfig, dockerfile, t, extrahosts, remote, retry, retryDelay, q, compatvolumes, nocache, cachefrom, pull, rm, forcerm, memory, memswap, cpushares, cpusetcpus, cpuperiod, cpuquota, buildargs, shmsize, squash, labels, networkmode, platform, target, outputs, inputStream);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("imageBuild", localVarResponse);
        }
        return new ApiResponse<ImageBuild200Response>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<ImageBuild200Response>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder imageBuildRequestBuilder(String contentType, String xRegistryConfig, String dockerfile, String t, String extrahosts, String remote, Integer retry, String retryDelay, Boolean q, Boolean compatvolumes, Boolean nocache, String cachefrom, Boolean pull, Boolean rm, Boolean forcerm, Integer memory, Integer memswap, Integer cpushares, String cpusetcpus, Integer cpuperiod, Integer cpuquota, String buildargs, Integer shmsize, Boolean squash, String labels, String networkmode, String platform, String target, String outputs, File inputStream) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/build";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "dockerfile";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("dockerfile", dockerfile));
    localVarQueryParameterBaseName = "t";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("t", t));
    localVarQueryParameterBaseName = "extrahosts";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("extrahosts", extrahosts));
    localVarQueryParameterBaseName = "remote";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("remote", remote));
    localVarQueryParameterBaseName = "retry";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("retry", retry));
    localVarQueryParameterBaseName = "retry-delay";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("retry-delay", retryDelay));
    localVarQueryParameterBaseName = "q";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("q", q));
    localVarQueryParameterBaseName = "compatvolumes";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("compatvolumes", compatvolumes));
    localVarQueryParameterBaseName = "nocache";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("nocache", nocache));
    localVarQueryParameterBaseName = "cachefrom";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("cachefrom", cachefrom));
    localVarQueryParameterBaseName = "pull";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("pull", pull));
    localVarQueryParameterBaseName = "rm";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("rm", rm));
    localVarQueryParameterBaseName = "forcerm";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("forcerm", forcerm));
    localVarQueryParameterBaseName = "memory";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("memory", memory));
    localVarQueryParameterBaseName = "memswap";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("memswap", memswap));
    localVarQueryParameterBaseName = "cpushares";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("cpushares", cpushares));
    localVarQueryParameterBaseName = "cpusetcpus";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("cpusetcpus", cpusetcpus));
    localVarQueryParameterBaseName = "cpuperiod";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("cpuperiod", cpuperiod));
    localVarQueryParameterBaseName = "cpuquota";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("cpuquota", cpuquota));
    localVarQueryParameterBaseName = "buildargs";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("buildargs", buildargs));
    localVarQueryParameterBaseName = "shmsize";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("shmsize", shmsize));
    localVarQueryParameterBaseName = "squash";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("squash", squash));
    localVarQueryParameterBaseName = "labels";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("labels", labels));
    localVarQueryParameterBaseName = "networkmode";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("networkmode", networkmode));
    localVarQueryParameterBaseName = "platform";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("platform", platform));
    localVarQueryParameterBaseName = "target";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("target", target));
    localVarQueryParameterBaseName = "outputs";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("outputs", outputs));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    if (contentType != null) {
      localVarRequestBuilder.header("Content-Type", contentType.toString());
    }
    if (xRegistryConfig != null) {
      localVarRequestBuilder.header("X-Registry-Config", xRegistryConfig.toString());
    }
    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(inputStream);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Create an image
   * Create an image by either pulling it from a registry or importing it.
   * @param xRegistryAuth A base64-encoded auth configuration. (optional)
   * @param fromImage Name of the image to pull. The name may include a tag or digest. This parameter may only be used when pulling an image. The pull is cancelled if the HTTP connection is closed. (optional)
   * @param fromSrc Source to import. The value may be a URL from which the image can be retrieved or - to read the image from the request body. This parameter may only be used when importing an image (optional)
   * @param repo Repository name given to an image when it is imported. The repo may include a tag. This parameter may only be used when importing an image. (optional)
   * @param tag Tag or digest. If empty when pulling an image, this causes all tags for the given image to be pulled. (optional)
   * @param message Set commit message for imported image. (optional)
   * @param platform Platform in the format os[/arch[/variant]] (optional)
   * @param inputImage Image content if fromSrc parameter was used (optional)
   * @return File
   * @throws ApiException if fails to make API call
   */
  public File imageCreate(String xRegistryAuth, String fromImage, String fromSrc, String repo, String tag, String message, String platform, File inputImage) throws ApiException {
    ApiResponse<File> localVarResponse = imageCreateWithHttpInfo(xRegistryAuth, fromImage, fromSrc, repo, tag, message, platform, inputImage);
    return localVarResponse.getData();
  }

  /**
   * Create an image
   * Create an image by either pulling it from a registry or importing it.
   * @param xRegistryAuth A base64-encoded auth configuration. (optional)
   * @param fromImage Name of the image to pull. The name may include a tag or digest. This parameter may only be used when pulling an image. The pull is cancelled if the HTTP connection is closed. (optional)
   * @param fromSrc Source to import. The value may be a URL from which the image can be retrieved or - to read the image from the request body. This parameter may only be used when importing an image (optional)
   * @param repo Repository name given to an image when it is imported. The repo may include a tag. This parameter may only be used when importing an image. (optional)
   * @param tag Tag or digest. If empty when pulling an image, this causes all tags for the given image to be pulled. (optional)
   * @param message Set commit message for imported image. (optional)
   * @param platform Platform in the format os[/arch[/variant]] (optional)
   * @param inputImage Image content if fromSrc parameter was used (optional)
   * @return ApiResponse&lt;File&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<File> imageCreateWithHttpInfo(String xRegistryAuth, String fromImage, String fromSrc, String repo, String tag, String message, String platform, File inputImage) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = imageCreateRequestBuilder(xRegistryAuth, fromImage, fromSrc, repo, tag, message, platform, inputImage);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("imageCreate", localVarResponse);
        }
        return new ApiResponse<File>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<File>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder imageCreateRequestBuilder(String xRegistryAuth, String fromImage, String fromSrc, String repo, String tag, String message, String platform, File inputImage) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/images/create";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "fromImage";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("fromImage", fromImage));
    localVarQueryParameterBaseName = "fromSrc";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("fromSrc", fromSrc));
    localVarQueryParameterBaseName = "repo";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("repo", repo));
    localVarQueryParameterBaseName = "tag";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("tag", tag));
    localVarQueryParameterBaseName = "message";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("message", message));
    localVarQueryParameterBaseName = "platform";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("platform", platform));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    if (xRegistryAuth != null) {
      localVarRequestBuilder.header("X-Registry-Auth", xRegistryAuth.toString());
    }
    localVarRequestBuilder.header("Content-Type", "text/plain");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(inputImage);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Remove Image
   * Delete an image from local storage
   * @param name name or ID of image to delete (required)
   * @param force remove the image even if used by containers or has other tags (optional)
   * @param noprune do not remove dangling parent images (optional)
   * @return List&lt;ImageDelete200ResponseInner&gt;
   * @throws ApiException if fails to make API call
   */
  public List<ImageDelete200ResponseInner> imageDelete(String name, Boolean force, Boolean noprune) throws ApiException {
    ApiResponse<List<ImageDelete200ResponseInner>> localVarResponse = imageDeleteWithHttpInfo(name, force, noprune);
    return localVarResponse.getData();
  }

  /**
   * Remove Image
   * Delete an image from local storage
   * @param name name or ID of image to delete (required)
   * @param force remove the image even if used by containers or has other tags (optional)
   * @param noprune do not remove dangling parent images (optional)
   * @return ApiResponse&lt;List&lt;ImageDelete200ResponseInner&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<List<ImageDelete200ResponseInner>> imageDeleteWithHttpInfo(String name, Boolean force, Boolean noprune) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = imageDeleteRequestBuilder(name, force, noprune);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("imageDelete", localVarResponse);
        }
        return new ApiResponse<List<ImageDelete200ResponseInner>>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<List<ImageDelete200ResponseInner>>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder imageDeleteRequestBuilder(String name, Boolean force, Boolean noprune) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling imageDelete");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/images/{name}"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "force";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("force", force));
    localVarQueryParameterBaseName = "noprune";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("noprune", noprune));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("DELETE", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Export an image
   * Export an image in tarball format
   * @param name the name or ID of the container (required)
   * @return File
   * @throws ApiException if fails to make API call
   */
  public File imageGet(String name) throws ApiException {
    ApiResponse<File> localVarResponse = imageGetWithHttpInfo(name);
    return localVarResponse.getData();
  }

  /**
   * Export an image
   * Export an image in tarball format
   * @param name the name or ID of the container (required)
   * @return ApiResponse&lt;File&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<File> imageGetWithHttpInfo(String name) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = imageGetRequestBuilder(name);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("imageGet", localVarResponse);
        }
        return new ApiResponse<File>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<File>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder imageGetRequestBuilder(String name) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling imageGet");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/images/{name}/get"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/x-tar");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Export several images
   * Get a tarball containing all images and metadata for several image repositories
   * @param names one or more image names or IDs comma separated (required)
   * @return File
   * @throws ApiException if fails to make API call
   */
  public File imageGetAll(String names) throws ApiException {
    ApiResponse<File> localVarResponse = imageGetAllWithHttpInfo(names);
    return localVarResponse.getData();
  }

  /**
   * Export several images
   * Get a tarball containing all images and metadata for several image repositories
   * @param names one or more image names or IDs comma separated (required)
   * @return ApiResponse&lt;File&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<File> imageGetAllWithHttpInfo(String names) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = imageGetAllRequestBuilder(names);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("imageGetAll", localVarResponse);
        }
        return new ApiResponse<File>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<File>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder imageGetAllRequestBuilder(String names) throws ApiException {
    // verify the required parameter 'names' is set
    if (names == null) {
      throw new ApiException(400, "Missing the required parameter 'names' when calling imageGetAll");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/images/get";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "names";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("names", names));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * History of an image
   * Return parent layers of an image.
   * @param name the name or ID of the container (required)
   * @return HistoryResponse
   * @throws ApiException if fails to make API call
   */
  public HistoryResponse imageHistory(String name) throws ApiException {
    ApiResponse<HistoryResponse> localVarResponse = imageHistoryWithHttpInfo(name);
    return localVarResponse.getData();
  }

  /**
   * History of an image
   * Return parent layers of an image.
   * @param name the name or ID of the container (required)
   * @return ApiResponse&lt;HistoryResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<HistoryResponse> imageHistoryWithHttpInfo(String name) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = imageHistoryRequestBuilder(name);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("imageHistory", localVarResponse);
        }
        return new ApiResponse<HistoryResponse>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<HistoryResponse>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder imageHistoryRequestBuilder(String name) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling imageHistory");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/images/{name}/history"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Inspect an image
   * Return low-level information about an image.
   * @param name the name or ID of the container (required)
   * @return ImageInspect
   * @throws ApiException if fails to make API call
   */
  public ImageInspect imageInspect(String name) throws ApiException {
    ApiResponse<ImageInspect> localVarResponse = imageInspectWithHttpInfo(name);
    return localVarResponse.getData();
  }

  /**
   * Inspect an image
   * Return low-level information about an image.
   * @param name the name or ID of the container (required)
   * @return ApiResponse&lt;ImageInspect&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ImageInspect> imageInspectWithHttpInfo(String name) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = imageInspectRequestBuilder(name);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("imageInspect", localVarResponse);
        }
        return new ApiResponse<ImageInspect>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<ImageInspect>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder imageInspectRequestBuilder(String name) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling imageInspect");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/images/{name}/json"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * List Images
   * Returns a list of images on the server. Note that it uses a different, smaller representation of an image than inspecting a single image.
   * @param all Show all images. Only images from a final layer (no children) are shown by default. (optional, default to false)
   * @param filters A JSON encoded value of the filters (a &#x60;map[string][]string&#x60;) to process on the images list. Available filters: - &#x60;before&#x60;&#x3D;(&#x60;&lt;image-name&gt;[:&lt;tag&gt;]&#x60;,  &#x60;&lt;image id&gt;&#x60; or &#x60;&lt;image@digest&gt;&#x60;) - &#x60;dangling&#x3D;true&#x60; - &#x60;label&#x3D;key&#x60; or &#x60;label&#x3D;\&quot;key&#x3D;value\&quot;&#x60; of an image label - &#x60;reference&#x60;&#x3D;(&#x60;&lt;image-name&gt;[:&lt;tag&gt;]&#x60;) - &#x60;since&#x60;&#x3D;(&#x60;&lt;image-name&gt;[:&lt;tag&gt;]&#x60;,  &#x60;&lt;image id&gt;&#x60; or &#x60;&lt;image@digest&gt;&#x60;)  (optional)
   * @param digests Not supported (optional, default to false)
   * @return List&lt;Summary&gt;
   * @throws ApiException if fails to make API call
   */
  public List<Summary> imageList(Boolean all, String filters, Boolean digests) throws ApiException {
    ApiResponse<List<Summary>> localVarResponse = imageListWithHttpInfo(all, filters, digests);
    return localVarResponse.getData();
  }

  /**
   * List Images
   * Returns a list of images on the server. Note that it uses a different, smaller representation of an image than inspecting a single image.
   * @param all Show all images. Only images from a final layer (no children) are shown by default. (optional, default to false)
   * @param filters A JSON encoded value of the filters (a &#x60;map[string][]string&#x60;) to process on the images list. Available filters: - &#x60;before&#x60;&#x3D;(&#x60;&lt;image-name&gt;[:&lt;tag&gt;]&#x60;,  &#x60;&lt;image id&gt;&#x60; or &#x60;&lt;image@digest&gt;&#x60;) - &#x60;dangling&#x3D;true&#x60; - &#x60;label&#x3D;key&#x60; or &#x60;label&#x3D;\&quot;key&#x3D;value\&quot;&#x60; of an image label - &#x60;reference&#x60;&#x3D;(&#x60;&lt;image-name&gt;[:&lt;tag&gt;]&#x60;) - &#x60;since&#x60;&#x3D;(&#x60;&lt;image-name&gt;[:&lt;tag&gt;]&#x60;,  &#x60;&lt;image id&gt;&#x60; or &#x60;&lt;image@digest&gt;&#x60;)  (optional)
   * @param digests Not supported (optional, default to false)
   * @return ApiResponse&lt;List&lt;Summary&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<List<Summary>> imageListWithHttpInfo(Boolean all, String filters, Boolean digests) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = imageListRequestBuilder(all, filters, digests);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("imageList", localVarResponse);
        }
        return new ApiResponse<List<Summary>>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<List<Summary>>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder imageListRequestBuilder(Boolean all, String filters, Boolean digests) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/images/json";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "all";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("all", all));
    localVarQueryParameterBaseName = "filters";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("filters", filters));
    localVarQueryParameterBaseName = "digests";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("digests", digests));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Import image
   * Load a set of images and tags into a repository.
   * @param quiet not supported (optional)
   * @param request tarball of container image (optional)
   * @throws ApiException if fails to make API call
   */
  public void imageLoad(Boolean quiet, String request) throws ApiException {
    imageLoadWithHttpInfo(quiet, request);
  }

  /**
   * Import image
   * Load a set of images and tags into a repository.
   * @param quiet not supported (optional)
   * @param request tarball of container image (optional)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> imageLoadWithHttpInfo(Boolean quiet, String request) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = imageLoadRequestBuilder(quiet, request);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("imageLoad", localVarResponse);
        }
        return new ApiResponse<Void>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
            // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder imageLoadRequestBuilder(Boolean quiet, String request) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/images/load";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "quiet";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("quiet", quiet));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofString(request));
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Prune unused images
   * Remove images from local storage that are not being used by a container
   * @param filters filters to apply to image pruning, encoded as JSON (map[string][]string). Available filters:   - &#x60;dangling&#x3D;&lt;boolean&gt;&#x60; When set to &#x60;true&#x60; (or &#x60;1&#x60;), prune only      unused *and* untagged images. When set to &#x60;false&#x60;      (or &#x60;0&#x60;), all unused images are pruned.   - &#x60;until&#x3D;&lt;string&gt;&#x60; Prune images created before this timestamp. The &#x60;&lt;timestamp&gt;&#x60; can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. &#x60;10m&#x60;, &#x60;1h30m&#x60;) computed relative to the daemon machine’s time.   - &#x60;label&#x60; (&#x60;label&#x3D;&lt;key&gt;&#x60;, &#x60;label&#x3D;&lt;key&gt;&#x3D;&lt;value&gt;&#x60;, &#x60;label!&#x3D;&lt;key&gt;&#x60;, or &#x60;label!&#x3D;&lt;key&gt;&#x3D;&lt;value&gt;&#x60;) Prune images with (or without, in case &#x60;label!&#x3D;...&#x60; is used) the specified labels.  (optional)
   * @return List&lt;ImageDelete200ResponseInner&gt;
   * @throws ApiException if fails to make API call
   */
  public List<ImageDelete200ResponseInner> imagePrune(String filters) throws ApiException {
    ApiResponse<List<ImageDelete200ResponseInner>> localVarResponse = imagePruneWithHttpInfo(filters);
    return localVarResponse.getData();
  }

  /**
   * Prune unused images
   * Remove images from local storage that are not being used by a container
   * @param filters filters to apply to image pruning, encoded as JSON (map[string][]string). Available filters:   - &#x60;dangling&#x3D;&lt;boolean&gt;&#x60; When set to &#x60;true&#x60; (or &#x60;1&#x60;), prune only      unused *and* untagged images. When set to &#x60;false&#x60;      (or &#x60;0&#x60;), all unused images are pruned.   - &#x60;until&#x3D;&lt;string&gt;&#x60; Prune images created before this timestamp. The &#x60;&lt;timestamp&gt;&#x60; can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. &#x60;10m&#x60;, &#x60;1h30m&#x60;) computed relative to the daemon machine’s time.   - &#x60;label&#x60; (&#x60;label&#x3D;&lt;key&gt;&#x60;, &#x60;label&#x3D;&lt;key&gt;&#x3D;&lt;value&gt;&#x60;, &#x60;label!&#x3D;&lt;key&gt;&#x60;, or &#x60;label!&#x3D;&lt;key&gt;&#x3D;&lt;value&gt;&#x60;) Prune images with (or without, in case &#x60;label!&#x3D;...&#x60; is used) the specified labels.  (optional)
   * @return ApiResponse&lt;List&lt;ImageDelete200ResponseInner&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<List<ImageDelete200ResponseInner>> imagePruneWithHttpInfo(String filters) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = imagePruneRequestBuilder(filters);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("imagePrune", localVarResponse);
        }
        return new ApiResponse<List<ImageDelete200ResponseInner>>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<List<ImageDelete200ResponseInner>>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder imagePruneRequestBuilder(String filters) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/images/prune";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "filters";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("filters", filters));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Push Image
   * Push an image to a container registry
   * @param name Name of image to push. (required)
   * @param tag The tag to associate with the image on the registry. (optional)
   * @param all All indicates whether to push all images related to the image list (optional)
   * @param compress Use compression on image. (optional)
   * @param destination Allows for pushing the image to a different destination than the image refers to. (optional)
   * @param format Manifest type (oci, v2s1, or v2s2) to use when pushing an image. Default is manifest type of source, with fallbacks. (optional)
   * @param tlsVerify Require TLS verification. (optional, default to true)
   * @param xRegistryAuth A base64-encoded auth configuration. (optional)
   * @return File
   * @throws ApiException if fails to make API call
   */
  public File imagePush(String name, String tag, Boolean all, Boolean compress, String destination, String format, Boolean tlsVerify, String xRegistryAuth) throws ApiException {
    ApiResponse<File> localVarResponse = imagePushWithHttpInfo(name, tag, all, compress, destination, format, tlsVerify, xRegistryAuth);
    return localVarResponse.getData();
  }

  /**
   * Push Image
   * Push an image to a container registry
   * @param name Name of image to push. (required)
   * @param tag The tag to associate with the image on the registry. (optional)
   * @param all All indicates whether to push all images related to the image list (optional)
   * @param compress Use compression on image. (optional)
   * @param destination Allows for pushing the image to a different destination than the image refers to. (optional)
   * @param format Manifest type (oci, v2s1, or v2s2) to use when pushing an image. Default is manifest type of source, with fallbacks. (optional)
   * @param tlsVerify Require TLS verification. (optional, default to true)
   * @param xRegistryAuth A base64-encoded auth configuration. (optional)
   * @return ApiResponse&lt;File&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<File> imagePushWithHttpInfo(String name, String tag, Boolean all, Boolean compress, String destination, String format, Boolean tlsVerify, String xRegistryAuth) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = imagePushRequestBuilder(name, tag, all, compress, destination, format, tlsVerify, xRegistryAuth);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("imagePush", localVarResponse);
        }
        return new ApiResponse<File>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<File>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder imagePushRequestBuilder(String name, String tag, Boolean all, Boolean compress, String destination, String format, Boolean tlsVerify, String xRegistryAuth) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling imagePush");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/images/{name}/push"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "tag";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("tag", tag));
    localVarQueryParameterBaseName = "all";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("all", all));
    localVarQueryParameterBaseName = "compress";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("compress", compress));
    localVarQueryParameterBaseName = "destination";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("destination", destination));
    localVarQueryParameterBaseName = "format";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("format", format));
    localVarQueryParameterBaseName = "tlsVerify";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("tlsVerify", tlsVerify));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    if (xRegistryAuth != null) {
      localVarRequestBuilder.header("X-Registry-Auth", xRegistryAuth.toString());
    }
    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Search images
   * Search registries for an image
   * @param term term to search (optional)
   * @param limit maximum number of results (optional, default to 25)
   * @param filters A JSON encoded value of the filters (a &#x60;map[string][]string&#x60;) to process on the images list. Available filters: - &#x60;is-automated&#x3D;(true|false)&#x60; - &#x60;is-official&#x3D;(true|false)&#x60; - &#x60;stars&#x3D;&lt;number&gt;&#x60; Matches images that have at least &#39;number&#39; stars.  (optional)
   * @param tlsVerify Require HTTPS and verify signatures when contacting registries. (optional, default to true)
   * @param listTags list the available tags in the repository (optional)
   * @return ImageSearch200Response
   * @throws ApiException if fails to make API call
   */
  public ImageSearch200Response imageSearch(String term, Integer limit, String filters, Boolean tlsVerify, Boolean listTags) throws ApiException {
    ApiResponse<ImageSearch200Response> localVarResponse = imageSearchWithHttpInfo(term, limit, filters, tlsVerify, listTags);
    return localVarResponse.getData();
  }

  /**
   * Search images
   * Search registries for an image
   * @param term term to search (optional)
   * @param limit maximum number of results (optional, default to 25)
   * @param filters A JSON encoded value of the filters (a &#x60;map[string][]string&#x60;) to process on the images list. Available filters: - &#x60;is-automated&#x3D;(true|false)&#x60; - &#x60;is-official&#x3D;(true|false)&#x60; - &#x60;stars&#x3D;&lt;number&gt;&#x60; Matches images that have at least &#39;number&#39; stars.  (optional)
   * @param tlsVerify Require HTTPS and verify signatures when contacting registries. (optional, default to true)
   * @param listTags list the available tags in the repository (optional)
   * @return ApiResponse&lt;ImageSearch200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ImageSearch200Response> imageSearchWithHttpInfo(String term, Integer limit, String filters, Boolean tlsVerify, Boolean listTags) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = imageSearchRequestBuilder(term, limit, filters, tlsVerify, listTags);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("imageSearch", localVarResponse);
        }
        return new ApiResponse<ImageSearch200Response>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<ImageSearch200Response>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder imageSearchRequestBuilder(String term, Integer limit, String filters, Boolean tlsVerify, Boolean listTags) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/images/search";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "term";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("term", term));
    localVarQueryParameterBaseName = "limit";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit", limit));
    localVarQueryParameterBaseName = "filters";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("filters", filters));
    localVarQueryParameterBaseName = "tlsVerify";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("tlsVerify", tlsVerify));
    localVarQueryParameterBaseName = "listTags";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("listTags", listTags));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Tag an image
   * Tag an image so that it becomes part of a repository.
   * @param name the name or ID of the container (required)
   * @param repo the repository to tag in (optional)
   * @param tag the name of the new tag (optional)
   * @throws ApiException if fails to make API call
   */
  public void imageTag(String name, String repo, String tag) throws ApiException {
    imageTagWithHttpInfo(name, repo, tag);
  }

  /**
   * Tag an image
   * Tag an image so that it becomes part of a repository.
   * @param name the name or ID of the container (required)
   * @param repo the repository to tag in (optional)
   * @param tag the name of the new tag (optional)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> imageTagWithHttpInfo(String name, String repo, String tag) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = imageTagRequestBuilder(name, repo, tag);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("imageTag", localVarResponse);
        }
        return new ApiResponse<Void>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
            // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder imageTagRequestBuilder(String name, String repo, String tag) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling imageTag");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/images/{name}/tag"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "repo";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("repo", repo));
    localVarQueryParameterBaseName = "tag";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("tag", tag));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

}
