/*
 * supports a RESTful API for the Libpod library
 * This documentation describes the Podman v2.x+ RESTful API. It consists of a Docker-compatible API and a Libpod API providing support for Podmanâ€™s unique features such as pods.  To start the service and keep it running for 5,000 seconds (-t 0 runs forever):  podman system service -t 5000 &  You can then use cURL on the socket using requests documented below.  NOTE: if you install the package podman-docker, it will create a symbolic link for /run/docker.sock to /run/podman/podman.sock  NOTE: Some fields in the API response JSON are encoded as omitempty, which means that if said field has a zero value, they will not be encoded in the API response. This is a feature to help reduce the size of the JSON responses returned via the API.  NOTE: Due to the limitations of [go-swagger](https://github.com/go-swagger/go-swagger), some field values that have a complex type show up as null in the docs as well as in the API responses. This is because the zero value for the field type is null. The field description in the docs will state what type the field is expected to be for such cases.  See podman-system-service(1) for more information.  Quick Examples:  'podman info'  curl --unix-socket /run/podman/podman.sock http://d/v5.0.0/libpod/info  'podman pull quay.io/containers/podman'  curl -XPOST --unix-socket /run/podman/podman.sock -v 'http://d/v5.0.0/images/create?fromImage=quay.io%2Fcontainers%2Fpodman'  'podman list images'  curl --unix-socket /run/podman/podman.sock -v 'http://d/v5.0.0/libpod/images/json' | jq
 *
 * The version of the OpenAPI document: 5.0.0
 * Contact: podman@lists.podman.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.github.alersrt.pod4j.openapi.model;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.StringJoiner;
import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import io.github.alersrt.pod4j.openapi.model.Config;
import io.github.alersrt.pod4j.openapi.model.GraphDriverData;
import io.github.alersrt.pod4j.openapi.model.Metadata;
import io.github.alersrt.pod4j.openapi.model.RootFS;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import jakarta.validation.constraints.*;
import jakarta.validation.Valid;


import io.github.alersrt.pod4j.openapi.ApiClient;
/**
 * ImageInspect
 */
@JsonPropertyOrder({
  ImageInspect.JSON_PROPERTY_ARCHITECTURE,
  ImageInspect.JSON_PROPERTY_AUTHOR,
  ImageInspect.JSON_PROPERTY_COMMENT,
  ImageInspect.JSON_PROPERTY_CONFIG,
  ImageInspect.JSON_PROPERTY_CONTAINER,
  ImageInspect.JSON_PROPERTY_CONTAINER_CONFIG,
  ImageInspect.JSON_PROPERTY_CREATED,
  ImageInspect.JSON_PROPERTY_DOCKER_VERSION,
  ImageInspect.JSON_PROPERTY_GRAPH_DRIVER,
  ImageInspect.JSON_PROPERTY_ID,
  ImageInspect.JSON_PROPERTY_METADATA,
  ImageInspect.JSON_PROPERTY_OS,
  ImageInspect.JSON_PROPERTY_OS_VERSION,
  ImageInspect.JSON_PROPERTY_PARENT,
  ImageInspect.JSON_PROPERTY_REPO_DIGESTS,
  ImageInspect.JSON_PROPERTY_REPO_TAGS,
  ImageInspect.JSON_PROPERTY_ROOT_F_S,
  ImageInspect.JSON_PROPERTY_SIZE,
  ImageInspect.JSON_PROPERTY_VARIANT,
  ImageInspect.JSON_PROPERTY_VIRTUAL_SIZE
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-11-28T19:32:38.690938181+07:00[Asia/Barnaul]", comments = "Generator version: 7.7.0")
public class ImageInspect {
  public static final String JSON_PROPERTY_ARCHITECTURE = "Architecture";
  private String architecture;

  public static final String JSON_PROPERTY_AUTHOR = "Author";
  private String author;

  public static final String JSON_PROPERTY_COMMENT = "Comment";
  private String comment;

  public static final String JSON_PROPERTY_CONFIG = "Config";
  private Config config;

  public static final String JSON_PROPERTY_CONTAINER = "Container";
  private String container;

  public static final String JSON_PROPERTY_CONTAINER_CONFIG = "ContainerConfig";
  private Config containerConfig;

  public static final String JSON_PROPERTY_CREATED = "Created";
  private String created;

  public static final String JSON_PROPERTY_DOCKER_VERSION = "DockerVersion";
  private String dockerVersion;

  public static final String JSON_PROPERTY_GRAPH_DRIVER = "GraphDriver";
  private GraphDriverData graphDriver;

  public static final String JSON_PROPERTY_ID = "Id";
  private String id;

  public static final String JSON_PROPERTY_METADATA = "Metadata";
  private Metadata metadata;

  public static final String JSON_PROPERTY_OS = "Os";
  private String os;

  public static final String JSON_PROPERTY_OS_VERSION = "OsVersion";
  private String osVersion;

  public static final String JSON_PROPERTY_PARENT = "Parent";
  private String parent;

  public static final String JSON_PROPERTY_REPO_DIGESTS = "RepoDigests";
  private List<String> repoDigests = new ArrayList<>();

  public static final String JSON_PROPERTY_REPO_TAGS = "RepoTags";
  private List<String> repoTags = new ArrayList<>();

  public static final String JSON_PROPERTY_ROOT_F_S = "RootFS";
  private RootFS rootFS;

  public static final String JSON_PROPERTY_SIZE = "Size";
  private Long size;

  public static final String JSON_PROPERTY_VARIANT = "Variant";
  private String variant;

  public static final String JSON_PROPERTY_VIRTUAL_SIZE = "VirtualSize";
  private Long virtualSize;

  public ImageInspect() { 
  }

  public ImageInspect architecture(String architecture) {
    this.architecture = architecture;
    return this;
  }

  /**
   * Architecture is the hardware CPU architecture that the image runs on.
   * @return architecture
   */
  @javax.annotation.Nullable

  @JsonProperty(JSON_PROPERTY_ARCHITECTURE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getArchitecture() {
    return architecture;
  }


  @JsonProperty(JSON_PROPERTY_ARCHITECTURE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setArchitecture(String architecture) {
    this.architecture = architecture;
  }


  public ImageInspect author(String author) {
    this.author = author;
    return this;
  }

  /**
   * Author is the name of the author that was specified when committing the image, or as specified through MAINTAINER (deprecated) in the Dockerfile.
   * @return author
   */
  @javax.annotation.Nullable

  @JsonProperty(JSON_PROPERTY_AUTHOR)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getAuthor() {
    return author;
  }


  @JsonProperty(JSON_PROPERTY_AUTHOR)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAuthor(String author) {
    this.author = author;
  }


  public ImageInspect comment(String comment) {
    this.comment = comment;
    return this;
  }

  /**
   * Comment is an optional message that can be set when committing or importing the image.
   * @return comment
   */
  @javax.annotation.Nullable

  @JsonProperty(JSON_PROPERTY_COMMENT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getComment() {
    return comment;
  }


  @JsonProperty(JSON_PROPERTY_COMMENT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setComment(String comment) {
    this.comment = comment;
  }


  public ImageInspect config(Config config) {
    this.config = config;
    return this;
  }

  /**
   * Get config
   * @return config
   */
  @javax.annotation.Nullable
  @Valid

  @JsonProperty(JSON_PROPERTY_CONFIG)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Config getConfig() {
    return config;
  }


  @JsonProperty(JSON_PROPERTY_CONFIG)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setConfig(Config config) {
    this.config = config;
  }


  public ImageInspect container(String container) {
    this.container = container;
    return this;
  }

  /**
   * Container is for backwards compat but is basically unused
   * @return container
   */
  @javax.annotation.Nullable

  @JsonProperty(JSON_PROPERTY_CONTAINER)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getContainer() {
    return container;
  }


  @JsonProperty(JSON_PROPERTY_CONTAINER)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setContainer(String container) {
    this.container = container;
  }


  public ImageInspect containerConfig(Config containerConfig) {
    this.containerConfig = containerConfig;
    return this;
  }

  /**
   * Get containerConfig
   * @return containerConfig
   */
  @javax.annotation.Nullable
  @Valid

  @JsonProperty(JSON_PROPERTY_CONTAINER_CONFIG)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Config getContainerConfig() {
    return containerConfig;
  }


  @JsonProperty(JSON_PROPERTY_CONTAINER_CONFIG)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setContainerConfig(Config containerConfig) {
    this.containerConfig = containerConfig;
  }


  public ImageInspect created(String created) {
    this.created = created;
    return this;
  }

  /**
   * Created is the date and time at which the image was created, formatted in RFC 3339 nano-seconds (time.RFC3339Nano).  This information is only available if present in the image, and omitted otherwise.
   * @return created
   */
  @javax.annotation.Nullable

  @JsonProperty(JSON_PROPERTY_CREATED)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getCreated() {
    return created;
  }


  @JsonProperty(JSON_PROPERTY_CREATED)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setCreated(String created) {
    this.created = created;
  }


  public ImageInspect dockerVersion(String dockerVersion) {
    this.dockerVersion = dockerVersion;
    return this;
  }

  /**
   * DockerVersion is the version of Docker that was used to build the image.  Depending on how the image was created, this field may be empty.
   * @return dockerVersion
   */
  @javax.annotation.Nullable

  @JsonProperty(JSON_PROPERTY_DOCKER_VERSION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getDockerVersion() {
    return dockerVersion;
  }


  @JsonProperty(JSON_PROPERTY_DOCKER_VERSION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setDockerVersion(String dockerVersion) {
    this.dockerVersion = dockerVersion;
  }


  public ImageInspect graphDriver(GraphDriverData graphDriver) {
    this.graphDriver = graphDriver;
    return this;
  }

  /**
   * Get graphDriver
   * @return graphDriver
   */
  @javax.annotation.Nullable
  @Valid

  @JsonProperty(JSON_PROPERTY_GRAPH_DRIVER)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public GraphDriverData getGraphDriver() {
    return graphDriver;
  }


  @JsonProperty(JSON_PROPERTY_GRAPH_DRIVER)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setGraphDriver(GraphDriverData graphDriver) {
    this.graphDriver = graphDriver;
  }


  public ImageInspect id(String id) {
    this.id = id;
    return this;
  }

  /**
   * ID is the content-addressable ID of an image.  This identifier is a content-addressable digest calculated from the image&#39;s configuration (which includes the digests of layers used by the image).  Note that this digest differs from the &#x60;RepoDigests&#x60; below, which holds digests of image manifests that reference the image.
   * @return id
   */
  @javax.annotation.Nullable

  @JsonProperty(JSON_PROPERTY_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getId() {
    return id;
  }


  @JsonProperty(JSON_PROPERTY_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setId(String id) {
    this.id = id;
  }


  public ImageInspect metadata(Metadata metadata) {
    this.metadata = metadata;
    return this;
  }

  /**
   * Get metadata
   * @return metadata
   */
  @javax.annotation.Nullable
  @Valid

  @JsonProperty(JSON_PROPERTY_METADATA)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Metadata getMetadata() {
    return metadata;
  }


  @JsonProperty(JSON_PROPERTY_METADATA)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setMetadata(Metadata metadata) {
    this.metadata = metadata;
  }


  public ImageInspect os(String os) {
    this.os = os;
    return this;
  }

  /**
   * OS is the Operating System the image is built to run on.
   * @return os
   */
  @javax.annotation.Nullable

  @JsonProperty(JSON_PROPERTY_OS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getOs() {
    return os;
  }


  @JsonProperty(JSON_PROPERTY_OS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setOs(String os) {
    this.os = os;
  }


  public ImageInspect osVersion(String osVersion) {
    this.osVersion = osVersion;
    return this;
  }

  /**
   * OsVersion is the version of the Operating System the image is built to run on (especially for Windows).
   * @return osVersion
   */
  @javax.annotation.Nullable

  @JsonProperty(JSON_PROPERTY_OS_VERSION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getOsVersion() {
    return osVersion;
  }


  @JsonProperty(JSON_PROPERTY_OS_VERSION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setOsVersion(String osVersion) {
    this.osVersion = osVersion;
  }


  public ImageInspect parent(String parent) {
    this.parent = parent;
    return this;
  }

  /**
   * Parent is the ID of the parent image.  Depending on how the image was created, this field may be empty and is only set for images that were built/created locally. This field is empty if the image was pulled from an image registry.
   * @return parent
   */
  @javax.annotation.Nullable

  @JsonProperty(JSON_PROPERTY_PARENT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getParent() {
    return parent;
  }


  @JsonProperty(JSON_PROPERTY_PARENT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setParent(String parent) {
    this.parent = parent;
  }


  public ImageInspect repoDigests(List<String> repoDigests) {
    this.repoDigests = repoDigests;
    return this;
  }

  public ImageInspect addRepoDigestsItem(String repoDigestsItem) {
    if (this.repoDigests == null) {
      this.repoDigests = new ArrayList<>();
    }
    this.repoDigests.add(repoDigestsItem);
    return this;
  }

  /**
   * RepoDigests is a list of content-addressable digests of locally available image manifests that the image is referenced from. Multiple manifests can refer to the same image.  These digests are usually only available if the image was either pulled from a registry, or if the image was pushed to a registry, which is when the manifest is generated and its digest calculated.
   * @return repoDigests
   */
  @javax.annotation.Nullable

  @JsonProperty(JSON_PROPERTY_REPO_DIGESTS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<String> getRepoDigests() {
    return repoDigests;
  }


  @JsonProperty(JSON_PROPERTY_REPO_DIGESTS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRepoDigests(List<String> repoDigests) {
    this.repoDigests = repoDigests;
  }


  public ImageInspect repoTags(List<String> repoTags) {
    this.repoTags = repoTags;
    return this;
  }

  public ImageInspect addRepoTagsItem(String repoTagsItem) {
    if (this.repoTags == null) {
      this.repoTags = new ArrayList<>();
    }
    this.repoTags.add(repoTagsItem);
    return this;
  }

  /**
   * RepoTags is a list of image names/tags in the local image cache that reference this image.  Multiple image tags can refer to the same image, and this list may be empty if no tags reference the image, in which case the image is \&quot;untagged\&quot;, in which case it can still be referenced by its ID.
   * @return repoTags
   */
  @javax.annotation.Nullable

  @JsonProperty(JSON_PROPERTY_REPO_TAGS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<String> getRepoTags() {
    return repoTags;
  }


  @JsonProperty(JSON_PROPERTY_REPO_TAGS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRepoTags(List<String> repoTags) {
    this.repoTags = repoTags;
  }


  public ImageInspect rootFS(RootFS rootFS) {
    this.rootFS = rootFS;
    return this;
  }

  /**
   * Get rootFS
   * @return rootFS
   */
  @javax.annotation.Nullable
  @Valid

  @JsonProperty(JSON_PROPERTY_ROOT_F_S)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public RootFS getRootFS() {
    return rootFS;
  }


  @JsonProperty(JSON_PROPERTY_ROOT_F_S)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRootFS(RootFS rootFS) {
    this.rootFS = rootFS;
  }


  public ImageInspect size(Long size) {
    this.size = size;
    return this;
  }

  /**
   * Size is the total size of the image including all layers it is composed of.
   * @return size
   */
  @javax.annotation.Nullable

  @JsonProperty(JSON_PROPERTY_SIZE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Long getSize() {
    return size;
  }


  @JsonProperty(JSON_PROPERTY_SIZE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSize(Long size) {
    this.size = size;
  }


  public ImageInspect variant(String variant) {
    this.variant = variant;
    return this;
  }

  /**
   * Variant is the CPU architecture variant (presently ARM-only).
   * @return variant
   */
  @javax.annotation.Nullable

  @JsonProperty(JSON_PROPERTY_VARIANT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getVariant() {
    return variant;
  }


  @JsonProperty(JSON_PROPERTY_VARIANT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setVariant(String variant) {
    this.variant = variant;
  }


  public ImageInspect virtualSize(Long virtualSize) {
    this.virtualSize = virtualSize;
    return this;
  }

  /**
   * VirtualSize is the total size of the image including all layers it is composed of.  Deprecated: this field is omitted in API v1.44, but kept for backward compatibility. Use Size instead.
   * @return virtualSize
   */
  @javax.annotation.Nullable

  @JsonProperty(JSON_PROPERTY_VIRTUAL_SIZE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Long getVirtualSize() {
    return virtualSize;
  }


  @JsonProperty(JSON_PROPERTY_VIRTUAL_SIZE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setVirtualSize(Long virtualSize) {
    this.virtualSize = virtualSize;
  }


  /**
   * Return true if this ImageInspect object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ImageInspect imageInspect = (ImageInspect) o;
    return Objects.equals(this.architecture, imageInspect.architecture) &&
        Objects.equals(this.author, imageInspect.author) &&
        Objects.equals(this.comment, imageInspect.comment) &&
        Objects.equals(this.config, imageInspect.config) &&
        Objects.equals(this.container, imageInspect.container) &&
        Objects.equals(this.containerConfig, imageInspect.containerConfig) &&
        Objects.equals(this.created, imageInspect.created) &&
        Objects.equals(this.dockerVersion, imageInspect.dockerVersion) &&
        Objects.equals(this.graphDriver, imageInspect.graphDriver) &&
        Objects.equals(this.id, imageInspect.id) &&
        Objects.equals(this.metadata, imageInspect.metadata) &&
        Objects.equals(this.os, imageInspect.os) &&
        Objects.equals(this.osVersion, imageInspect.osVersion) &&
        Objects.equals(this.parent, imageInspect.parent) &&
        Objects.equals(this.repoDigests, imageInspect.repoDigests) &&
        Objects.equals(this.repoTags, imageInspect.repoTags) &&
        Objects.equals(this.rootFS, imageInspect.rootFS) &&
        Objects.equals(this.size, imageInspect.size) &&
        Objects.equals(this.variant, imageInspect.variant) &&
        Objects.equals(this.virtualSize, imageInspect.virtualSize);
  }

  @Override
  public int hashCode() {
    return Objects.hash(architecture, author, comment, config, container, containerConfig, created, dockerVersion, graphDriver, id, metadata, os, osVersion, parent, repoDigests, repoTags, rootFS, size, variant, virtualSize);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ImageInspect {\n");
    sb.append("    architecture: ").append(toIndentedString(architecture)).append("\n");
    sb.append("    author: ").append(toIndentedString(author)).append("\n");
    sb.append("    comment: ").append(toIndentedString(comment)).append("\n");
    sb.append("    config: ").append(toIndentedString(config)).append("\n");
    sb.append("    container: ").append(toIndentedString(container)).append("\n");
    sb.append("    containerConfig: ").append(toIndentedString(containerConfig)).append("\n");
    sb.append("    created: ").append(toIndentedString(created)).append("\n");
    sb.append("    dockerVersion: ").append(toIndentedString(dockerVersion)).append("\n");
    sb.append("    graphDriver: ").append(toIndentedString(graphDriver)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    os: ").append(toIndentedString(os)).append("\n");
    sb.append("    osVersion: ").append(toIndentedString(osVersion)).append("\n");
    sb.append("    parent: ").append(toIndentedString(parent)).append("\n");
    sb.append("    repoDigests: ").append(toIndentedString(repoDigests)).append("\n");
    sb.append("    repoTags: ").append(toIndentedString(repoTags)).append("\n");
    sb.append("    rootFS: ").append(toIndentedString(rootFS)).append("\n");
    sb.append("    size: ").append(toIndentedString(size)).append("\n");
    sb.append("    variant: ").append(toIndentedString(variant)).append("\n");
    sb.append("    virtualSize: ").append(toIndentedString(virtualSize)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

  /**
   * Convert the instance into URL query string.
   *
   * @return URL query string
   */
  public String toUrlQueryString() {
    return toUrlQueryString(null);
  }

  /**
   * Convert the instance into URL query string.
   *
   * @param prefix prefix of the query string
   * @return URL query string
   */
  public String toUrlQueryString(String prefix) {
    String suffix = "";
    String containerSuffix = "";
    String containerPrefix = "";
    if (prefix == null) {
      // style=form, explode=true, e.g. /pet?name=cat&type=manx
      prefix = "";
    } else {
      // deepObject style e.g. /pet?id[name]=cat&id[type]=manx
      prefix = prefix + "[";
      suffix = "]";
      containerSuffix = "]";
      containerPrefix = "[";
    }

    StringJoiner joiner = new StringJoiner("&");

    // add `Architecture` to the URL query string
    if (getArchitecture() != null) {
      joiner.add(String.format("%sArchitecture%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getArchitecture()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `Author` to the URL query string
    if (getAuthor() != null) {
      joiner.add(String.format("%sAuthor%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getAuthor()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `Comment` to the URL query string
    if (getComment() != null) {
      joiner.add(String.format("%sComment%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getComment()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `Config` to the URL query string
    if (getConfig() != null) {
      joiner.add(getConfig().toUrlQueryString(prefix + "Config" + suffix));
    }

    // add `Container` to the URL query string
    if (getContainer() != null) {
      joiner.add(String.format("%sContainer%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getContainer()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `ContainerConfig` to the URL query string
    if (getContainerConfig() != null) {
      joiner.add(getContainerConfig().toUrlQueryString(prefix + "ContainerConfig" + suffix));
    }

    // add `Created` to the URL query string
    if (getCreated() != null) {
      joiner.add(String.format("%sCreated%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getCreated()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `DockerVersion` to the URL query string
    if (getDockerVersion() != null) {
      joiner.add(String.format("%sDockerVersion%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getDockerVersion()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `GraphDriver` to the URL query string
    if (getGraphDriver() != null) {
      joiner.add(getGraphDriver().toUrlQueryString(prefix + "GraphDriver" + suffix));
    }

    // add `Id` to the URL query string
    if (getId() != null) {
      joiner.add(String.format("%sId%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getId()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `Metadata` to the URL query string
    if (getMetadata() != null) {
      joiner.add(getMetadata().toUrlQueryString(prefix + "Metadata" + suffix));
    }

    // add `Os` to the URL query string
    if (getOs() != null) {
      joiner.add(String.format("%sOs%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getOs()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `OsVersion` to the URL query string
    if (getOsVersion() != null) {
      joiner.add(String.format("%sOsVersion%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getOsVersion()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `Parent` to the URL query string
    if (getParent() != null) {
      joiner.add(String.format("%sParent%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getParent()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `RepoDigests` to the URL query string
    if (getRepoDigests() != null) {
      for (int i = 0; i < getRepoDigests().size(); i++) {
        joiner.add(String.format("%sRepoDigests%s%s=%s", prefix, suffix,
            "".equals(suffix) ? "" : String.format("%s%d%s", containerPrefix, i, containerSuffix),
            URLEncoder.encode(ApiClient.valueToString(getRepoDigests().get(i)), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
      }
    }

    // add `RepoTags` to the URL query string
    if (getRepoTags() != null) {
      for (int i = 0; i < getRepoTags().size(); i++) {
        joiner.add(String.format("%sRepoTags%s%s=%s", prefix, suffix,
            "".equals(suffix) ? "" : String.format("%s%d%s", containerPrefix, i, containerSuffix),
            URLEncoder.encode(ApiClient.valueToString(getRepoTags().get(i)), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
      }
    }

    // add `RootFS` to the URL query string
    if (getRootFS() != null) {
      joiner.add(getRootFS().toUrlQueryString(prefix + "RootFS" + suffix));
    }

    // add `Size` to the URL query string
    if (getSize() != null) {
      joiner.add(String.format("%sSize%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getSize()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `Variant` to the URL query string
    if (getVariant() != null) {
      joiner.add(String.format("%sVariant%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getVariant()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `VirtualSize` to the URL query string
    if (getVirtualSize() != null) {
      joiner.add(String.format("%sVirtualSize%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getVirtualSize()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    return joiner.toString();
  }
}

