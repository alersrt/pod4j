/*
 * supports a RESTful API for the Libpod library
 * This documentation describes the Podman v2.x+ RESTful API. It consists of a Docker-compatible API and a Libpod API providing support for Podman’s unique features such as pods.  To start the service and keep it running for 5,000 seconds (-t 0 runs forever):  podman system service -t 5000 &  You can then use cURL on the socket using requests documented below.  NOTE: if you install the package podman-docker, it will create a symbolic link for /run/docker.sock to /run/podman/podman.sock  NOTE: Some fields in the API response JSON are encoded as omitempty, which means that if said field has a zero value, they will not be encoded in the API response. This is a feature to help reduce the size of the JSON responses returned via the API.  NOTE: Due to the limitations of [go-swagger](https://github.com/go-swagger/go-swagger), some field values that have a complex type show up as null in the docs as well as in the API responses. This is because the zero value for the field type is null. The field description in the docs will state what type the field is expected to be for such cases.  See podman-system-service(1) for more information.  Quick Examples:  'podman info'  curl --unix-socket /run/podman/podman.sock http://d/v5.0.0/libpod/info  'podman pull quay.io/containers/podman'  curl -XPOST --unix-socket /run/podman/podman.sock -v 'http://d/v5.0.0/images/create?fromImage=quay.io%2Fcontainers%2Fpodman'  'podman list images'  curl --unix-socket /run/podman/podman.sock -v 'http://d/v5.0.0/libpod/images/json' | jq
 *
 * The version of the OpenAPI document: 5.0.0
 * Contact: podman@lists.podman.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.github.alersrt.pod4j.openapi.api;

import io.github.alersrt.pod4j.openapi.ApiException;
import io.github.alersrt.pod4j.openapi.model.ErrorModel;
import java.io.File;
import io.github.alersrt.pod4j.openapi.model.IdResponse;
import io.github.alersrt.pod4j.openapi.model.InspectPodData;
import io.github.alersrt.pod4j.openapi.model.ListPodsReport;
import io.github.alersrt.pod4j.openapi.model.PlayKubeReport;
import io.github.alersrt.pod4j.openapi.model.PodKillReport;
import io.github.alersrt.pod4j.openapi.model.PodPauseReport;
import io.github.alersrt.pod4j.openapi.model.PodPruneReport;
import io.github.alersrt.pod4j.openapi.model.PodRestartReport;
import io.github.alersrt.pod4j.openapi.model.PodRmReport;
import io.github.alersrt.pod4j.openapi.model.PodSpecGenerator;
import io.github.alersrt.pod4j.openapi.model.PodStartReport;
import io.github.alersrt.pod4j.openapi.model.PodStatsReport;
import io.github.alersrt.pod4j.openapi.model.PodStopReport;
import io.github.alersrt.pod4j.openapi.model.PodTopOKBody;
import io.github.alersrt.pod4j.openapi.model.PodUnpauseReport;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;


import jakarta.validation.constraints.*;
import jakarta.validation.Valid;

/**
 * API tests for PodsApi
 */
@Disabled
public class PodsApiTest {

    private final PodsApi api = new PodsApi();


    /**
     * Generate a Kubernetes YAML file.
     *
     * Generate Kubernetes YAML based on a pod or container.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void generateKubeLibpodTest() throws ApiException {
        List<String> names = null;
        Boolean service = null;
        String type = null;
        Integer replicas = null;
        Boolean noTrunc = null;
        Boolean podmanOnly = null;
        File response =
                api.generateKubeLibpod(names, service, type, replicas, noTrunc, podmanOnly);
        
        // TODO: test validations
    }

    /**
     * Generate Systemd Units
     *
     * Generate Systemd Units based on a pod or container.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void generateSystemdLibpodTest() throws ApiException {
        String name = null;
        Boolean useName = null;
        Boolean _new = null;
        Boolean noHeader = null;
        Integer startTimeout = null;
        Integer stopTimeout = null;
        String restartPolicy = null;
        String containerPrefix = null;
        String podPrefix = null;
        String separator = null;
        Integer restartSec = null;
        List<String> wants = null;
        List<String> after = null;
        List<String> requires = null;
        List<String> additionalEnvVariables = null;
        Map<String, String> response =
                api.generateSystemdLibpod(name, useName, _new, noHeader, startTimeout, stopTimeout, restartPolicy, containerPrefix, podPrefix, separator, restartSec, wants, after, requires, additionalEnvVariables);
        
        // TODO: test validations
    }

    /**
     * Apply a podman workload or Kubernetes YAML file.
     *
     * Deploy a podman container, pod, volume, or Kubernetes yaml to a Kubernetes cluster.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void kubeApplyLibpodTest() throws ApiException {
        String caCertFile = null;
        String kubeConfig = null;
        String namespace = null;
        Boolean service = null;
        String _file = null;
        String request = null;
        File response =
                api.kubeApplyLibpod(caCertFile, kubeConfig, namespace, service, _file, request);
        
        // TODO: test validations
    }

    /**
     * Remove resources created from kube play
     *
     * Tears down pods, secrets, and volumes defined in a YAML file
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void playKubeDownLibpodTest() throws ApiException {
        String contentType = null;
        Boolean force = null;
        String request = null;
        PlayKubeReport response =
                api.playKubeDownLibpod(contentType, force, request);
        
        // TODO: test validations
    }

    /**
     * Play a Kubernetes YAML file.
     *
     * Create and run pods based on a Kubernetes YAML file.  ### Content-Type  Then endpoint support two Content-Type  - &#x60;plain/text&#x60; for yaml format  - &#x60;application/x-tar&#x60; for sending context(s) required for building images  #### Tar format  The tar format must contain a &#x60;play.yaml&#x60; file at the root that will be used. If the file format requires context to build an image, it uses the image name and check for corresponding folder.  For example, the client sends a tar file with the following structure:  &#x60;&#x60;&#x60; └── content.tar  ├── play.yaml  └── foobar/      └── Containerfile &#x60;&#x60;&#x60;  The &#x60;play.yaml&#x60; is the following, the &#x60;foobar&#x60; image means we are looking for a context with this name. &#x60;&#x60;&#x60; apiVersion: v1 kind: Pod metadata: name: demo-build-remote spec: containers:  - name: container    image: foobar &#x60;&#x60;&#x60; 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void playKubeLibpodTest() throws ApiException {
        String contentType = null;
        String annotations = null;
        String logDriver = null;
        List<String> logOptions = null;
        List<String> network = null;
        Boolean noHosts = null;
        Boolean noTrunc = null;
        List<String> publishPorts = null;
        Boolean publishAllPorts = null;
        Boolean replace = null;
        Boolean serviceContainer = null;
        Boolean start = null;
        List<String> staticIPs = null;
        List<String> staticMACs = null;
        Boolean tlsVerify = null;
        String userns = null;
        Boolean wait = null;
        Boolean build = null;
        String request = null;
        PlayKubeReport response =
                api.playKubeLibpod(contentType, annotations, logDriver, logOptions, network, noHosts, noTrunc, publishPorts, publishAllPorts, replace, serviceContainer, start, staticIPs, staticMACs, tlsVerify, userns, wait, build, request);
        
        // TODO: test validations
    }

    /**
     * Create a pod
     *
     *
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void podCreateLibpodTest() throws ApiException {
        PodSpecGenerator create = null;
        IdResponse response =
                api.podCreateLibpod(create);
        
        // TODO: test validations
    }

    /**
     * Remove pod
     *
     *
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void podDeleteLibpodTest() throws ApiException {
        String name = null;
        Boolean force = null;
        PodRmReport response =
                api.podDeleteLibpod(name, force);
        
        // TODO: test validations
    }

    /**
     * Pod exists
     *
     * Check if a pod exists by name or ID
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void podExistsLibpodTest() throws ApiException {
        String name = null;

        api.podExistsLibpod(name);

        // TODO: test validations
    }

    /**
     * Inspect pod
     *
     *
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void podInspectLibpodTest() throws ApiException {
        String name = null;
        InspectPodData response =
                api.podInspectLibpod(name);
        
        // TODO: test validations
    }

    /**
     * Kill a pod
     *
     *
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void podKillLibpodTest() throws ApiException {
        String name = null;
        String signal = null;
        PodKillReport response =
                api.podKillLibpod(name, signal);
        
        // TODO: test validations
    }

    /**
     * List pods
     *
     *
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void podListLibpodTest() throws ApiException {
        String filters = null;
        List<ListPodsReport> response =
                api.podListLibpod(filters);
        
        // TODO: test validations
    }

    /**
     * Pause a pod
     *
     * Pause a pod
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void podPauseLibpodTest() throws ApiException {
        String name = null;
        PodPauseReport response =
                api.podPauseLibpod(name);
        
        // TODO: test validations
    }

    /**
     * Prune unused pods
     *
     *
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void podPruneLibpodTest() throws ApiException {
        PodPruneReport response =
                api.podPruneLibpod();
        
        // TODO: test validations
    }

    /**
     * Restart a pod
     *
     *
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void podRestartLibpodTest() throws ApiException {
        String name = null;
        PodRestartReport response =
                api.podRestartLibpod(name);
        
        // TODO: test validations
    }

    /**
     * Start a pod
     *
     *
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void podStartLibpodTest() throws ApiException {
        String name = null;
        PodStartReport response =
                api.podStartLibpod(name);
        
        // TODO: test validations
    }

    /**
     * Statistics for one or more pods
     *
     * Display a live stream of resource usage statistics for the containers in one or more pods
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void podStatsAllLibpodTest() throws ApiException {
        Boolean all = null;
        List<String> namesOrIDs = null;
        List<PodStatsReport> response =
                api.podStatsAllLibpod(all, namesOrIDs);
        
        // TODO: test validations
    }

    /**
     * Stop a pod
     *
     *
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void podStopLibpodTest() throws ApiException {
        String name = null;
        Integer t = null;
        PodStopReport response =
                api.podStopLibpod(name, t);
        
        // TODO: test validations
    }

    /**
     * List processes
     *
     * List processes running inside a pod
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void podTopLibpodTest() throws ApiException {
        String name = null;
        Boolean stream = null;
        Integer delay = null;
        String psArgs = null;
        PodTopOKBody response =
                api.podTopLibpod(name, stream, delay, psArgs);
        
        // TODO: test validations
    }

    /**
     * Unpause a pod
     *
     *
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void podUnpauseLibpodTest() throws ApiException {
        String name = null;
        PodUnpauseReport response =
                api.podUnpauseLibpod(name);
        
        // TODO: test validations
    }

}
